#  도커, 컨테이너, 쿠버네티스 정리

NCC를 사용하기 위해 알아야 할 용어들을 한번 정리해봤습니다. 

추가적으로 생각할 부분이 있으면 댓글로 남겨주시면 감사하겠습니다. :)



## 컨테이너

* 컨테이너란?

  > 하나의 OS위에 여러 어플리케이션들을 독립적으로 실행 및 격리된 환경을 지원해주고 패키징(OS, 라이브러리 포함) 해주는 일종의 가상화 기술



* VM vs Container

  1. VM은 OS위에 하드웨어를 설치하고 그위에 OS를 설치하기 때문에 많이 무겁고 시작 오버헤드가 큼
  2. 대규모 VM을 실행하는 경우 보통 동일한 OS 인스턴스와 부팅 볼륨이 중복되어 여러 개가 실행

  

  >  즉 컨테이너는 VM보다 능률적이고 가벼워 VM에 비해 더 많은 컨테이너를 실행

  

* 컨테이너의 특징
  * 서비스 단위로 컨테이너의 이미지를 만들어 사용 ->배포와 롤백을 간단 (CI / CD에 적합)
  * 언어나 프레임워크에 상관없이 어플리케이션을 동일한 방식으로 관리
  * 개발, 테스팅, 운영 환경은 물론 로컬 피시와 클라우드까지 동일한 환경을 구축
  * 특정 클라우드 벤더에 종속적이지 않음 -> AWS를 Azure로 변경하기 쉬움
  * MSA에 적합
    



* 컨테이너의 기능

  1. namespace

     * 하나의 시스템에서 독립적으로 프로세스를 격리시킬 수 있는 기능 (프로세스에 격리된 환경을 제공하고 전용 자원처럼 보이게 함)

     * 프로세스에게 격리된 OS View를 제공
     * 프로세스 생성 시점에 어떤 네임스페이스를 사용할지 선택 가능 - 같은 eth0 이더라도 서로 다른 네트워크 자원 사용
     * 프로세스는 선택한 네임스페이스 별로 격리

  2. cgroup

     * 프로세스가 사용할 수 있는 시스템 리소스를 제한하는 기능

     * 어플리케이션에게 하드웨어 자원을 그룹으로 묶어서 할당
     * cgroup으로 묶인 프로세스들은 자원 별로 정해진 양만 사용하게 설정 가능

  3. Union FileSystem

     * 서로 다른 파일 시스템이나 디렉토리를 합쳐서 하나의 논리적인 파일 시스템으로 컨테이너에게 제공
     * Union mount?
       * 복수의 파일 시스템을 하나의 파일 시스템으로 마운트하는 기능
       * 두 파일 시스템에서 동일한 파일이 있다면 나중에 마운트 된 파일 시스템으로 대치
       * 하위 파일 시스템에 대한 쓰기 작업은 복사본을 생성하여 수행하므로 원본 파일시스템은 변하지 않음

     * 컨테이너가 Namespace와 Cgroup에 의해 격리될 때 컨테이너가 사용할 파일 시스템도 격리되어야 함
     * unionfs을 사용하면 여러 컨테이너가 하나의 이미지를 사용할 경우 각각의 컨테이너는 자신이 overwrite할 영역만 유지할 수 있음



## 도커

* 도커란?

  > 컨테이너를 이미지 파일로 빌드하고 배포하여 어디서나 실행 할 수 있는 오픈 소스

* 구성요소

  * 도커는 클라이언트와 서버로 구성
  * 모든 명령은 클라언트에서 REST로 서버에 요청
  * 도커 서버는 자신만의 이미지 저장소를 가지고 있고 docker remote registry와 이미지를 주고 받음

* 동작 방식

  1. Docker Client는 DockerFile을 작성하여 Docker Server에 이미지 빌드 요청
  2. Docker Server는 이미지를 빌드하여 로컬 저장소에 저장
  3. Docker Push 명령을 받으면 Docker Server는 로컬의 이미지를 Docker Registry에 올림
  4. Doker Client는 Docker Run을 실행시켜 Docker Registery에 등록된 이미지를 로컬 저장소로 다운 받음
  5. Docker 이미지를 이용해 컨테이너를 실행



## Cotainer Orchestration

* 컨테이너 오케스트레이션이란?

  > 여러 호스트에서 다수의 어플리케이션을 운영/관리할 수 있게 해주는 도구

  

  * 컨테이너 오케트스레이션 특징

    * 클러스터

        * 중앙제어 - 하나의 군집화 된 단위로 관리, 마스터 서버를 둬 제어
        * 네트워킹 - 클러스터 된 노드끼리 네트워크가 잘 되야함
        * 노드 스케일 - 노드가 아무리 많아도 잘 돌아야 함
    * 상태

      * 상태 관리 - 도커 이미지 관리
    * 스케줄링

      * 배포 관리 - 어떤 서버에 뭐가 떠있는지 자동으로 체크
    * 롤백/ 롤아웃
        * 배포 버전 관리 - 중앙에서 버전 관리
    * 서비스 발견
        * 서비스 등록 및 조회 - 서버를 생성하면 자동으로 내부적으로 설정 변경
    * 볼륨
        * 볼륨 스토리지 - 마운트 관리 용이하게 만듬

  * 컨테이너 오케스트레이션 지원 영역
    * 스케쥴링 - 여러 호스트에 컨테이너를 분배하고 컨테이너나 호스트의 장애시 재분배
    * 네트워킹 - 여러 호스트에 분산된 컨테이너간의 네트워크와 L4/L7 등을 지원
    * 로깅 - 동적으로 분산되어 뜨고 내리는 컨테이너들의 로그를 조회
    * 모니터링 - 동적으로 분산되어 뜨고 내리는 컨테이너들의 모니터링 정보를 수집
    * 스토리지 - 여러 호스트간을 이동하며 운영되는 컨테이너가 접근할 리모트 스토리지를 제공



## 쿠버네티스

* 쿠버네티스란?

  >  컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼



* 쿠버네티스의 특징
    * Stateless, Stateful, 데이터 처리등 다양한 어플리케이션 타입을 컨테이너로 구동 할 수 있게 해줌
    * 컨테이너 오케스트레이션에서 사실상의 표준 (de facto)



* 쿠버네티스 아키텍처

  1. Master
     1. API Server
        * 상태를 바꾸거나 조회하는 역할
        * etcd와 유일하게 통신하는 모듈
        * Rest API형태로 제공
        * 권한 체크하여 요청 관리
        * 관리자 요청 뿐 아니라 다양한 내부 모듈과 통신
        * 수평 확장 가능
     2. etcd
        * 모든 상태와 데이터를 저장
        * 분산 시스템으로 구성하여 안정성을 높이고 가볍고 빠르면서 정확하게 설계
        * Key-Value 형태로 데이터 저장
        * Backup, TTL, watch등 기능 제공
     3. Scheduler
        * 새로 생성된 Pod을 감시하고 어디에 실행할지 노드를 선택
        * 노드의 현재 상태 체크 및 Pod의 요구 사항을 체크 (노드에 라벨을  부여)
     4. Controller
        * 계속 끊임없이 상태를 체크하고 원하는 상태로 유지
        * 복잡성을 낮추기 위해 단일 프로세스로 실행
        * 논리적으로 다양한 컨트롤러가 존재
  2. Node
     1. Proxy
        * API서버만 바라봄
        * 네트워크 부하 분산 역할
     2. Kubelet
        * API서버만 바라봄
        * Pod이랑 통신 (실행/중지등 상태 체크)
        * 각 노드에서 실행
* 쿠버네티스의 흐름

    1. 관리자가 API Server에 Pod 요청
    2. API Server는 etcd에 Pod 생성 요청이 들어왔다고 정보를 넣음
    3. 컨트롤러는 새로 생긴 Pod이 있나 계속 체크
    4. 새로 생긴 pod을 발견하면 컨트롤러는 Pod을 할당하는 요청을 다시 함
    5. API 서버는 컨트롤러가 요청한 것을 받아서 etcd에 할당 요청하라고 정보를 넣음
    6. 스케줄러는 계속 할당 요청이 들어온 Pod이 있는지 체크
    7. 새로 할당 요청 들어온 Pod을 발견하면 여러개의 노드 중에서 어디에 띄울지 정함
    8. 할당하면 API Server에 새 Pod 할당 확인 요청을 보냄
    9. API Server는 Pod 노드 할당하는데 상태는 아직 미실행이라고 etcd에 정보를 넣음
    10. Kubelet은 미실행 Pod 확인을 계속 API Server에 요청함
    11. 만약 미실행 Pod 이 있다면 Kubelet는 생성해주고 API 서버에 요청을 보냄
    12. API 서버는 etcd에 Pod이 실행중이라고 업데이트




> 계속 모든 상태를 체크해준다는 것이 중요




* 쿠버네티스 오브젝트
  * Pod
    * 쿠버네티스는 Pod을 배포
    * Pod은 가장 작은 배포 단위 -> 컨테이너를 배포하는 것이 아닌 Pod을 배포 
    * Pod 안에 컨테이너가 두개있을 수도 있음
      * Pod안에 컨테이너끼리 공유가 가능
    * 하지만 Pod의 직접 생성은 좋지 않음 -> 생명주기가 위태롭기 때문에 수시로 죽음
      * 따라서 replica 갯수를 끊임없이 맞추는 Deployment와 같은 Controller를 이용하는 것이 효과적임
  * ReplicaSet
    * 몇개의 Pod을 관리할지 정하는 요소
    * 예를들어 ``replicas = 4`` 면 pod 4개로 늘림
  * Deployment
    * 배포 버전을 관리하는 오브젝트
    * 버전을 올리고 싶으면 ReplicaSet을 2개로 만들어 ``replicas = 4 `` 이런식으로 값을 변경
  * DaemonSet
    * 모든 노드에 꼭 하나씩만 떠있길 원하는 Pod을 만들고 싶을 때 사용 (로그, 모니터링)
  * StatefulSets
    * 순서대로 팟을 실행시키거나 같은 볼륨을 재활용하고 싶을 때 사용
  * job
    * 한번 실행하고 죽는 Pod을 사용하고 싶을 때 사용
  * Service
    * Cluster IP 
      * Pod끼리 로드 밸런싱을 하는 오브젝트
      * IP가 언제든지 사라지고 바뀌는게 자유롭기 때문에 해당 오브젝트를 사용
    * Node port
      * 외부에서 요청을 하면 포트를 통해 내부 Service에 접근하게 만듬
    * LoadBalancer
      * 외부에서 node port를 적절히 밸런싱 시킴
      * 리소스를 과하게 사용할 수 있기 때문에 조심해야함
    * Ingress
      * 도메인 또는 경로별로 라우팅
      * 단 1개의 IP주소를 갖는 도메인을 통해 외부 통신
* 그 외
    * Volume - 저자소
    * Namespace - 논리적인 리소스 구분
    * ConfigMap/Secret - 설정
  
  
  
* 쿠버네티스 API 호출 예제 

  ```yaml
  apiVersion: v1 // api 버전
  kind: Pod // 오브젝트 종류
  metadata:
  	name: example // 메타 데이터 이름
  spec:
  	containers:
  		- name: busybox // container 이름
  			image: busybox:1.25 // 이미지 이름
  ```




> 원하는 상태를 다양한 오브젝트 (위에 예제)로 정의 하고 API 서버에 yaml 형식으로 전달




## NCC (Naver Container Cluster)

* NCC란?
  * 네이버 버전 쿠버네티스라 보면 됌
  * Multi-IDC로 서비스를 구축할 수 있도록 여러 쿠버네티스 클러스터로 구성되어 있음
  * 즉 사용자는 쿠버네티스를 쿠버네티스 네임스페이스 단위로 공유하며 사용
* 컨테이너 네트워킹
  * 쿠버네티스의 실행 단위인 Pod 별로 네이버 네트워크 상의 리얼 IP가 부여되어 접근 가능
  * 쿠버네티스 서비스 기반으로 동적 설정되는 L4 로드밸런서와 L7 프록시가 제공
* 컨테이너 스토리지
  * Block Starage Volume: Pod별로 리모트 Volume을 로컬 디스크처럼 마운트하여 제공
  * Shared Storage Volume: 여러 Pod가 공유하는 Nubes 스토리지를 쉽게 생성하여 사용할 수 있도록 제공
* 컨테이너 모니터링과 로깅
  * 사용자가 생성한 쿠버네티스 네임스페이스에는 Prometheus/grafana가 자동 제공하여 모니터링 가능
  * 사내 ESFarm이나 엘라스틱 서치를 직접 생성하여 Pod의 로그를 전송하고 조회할 수 있음

