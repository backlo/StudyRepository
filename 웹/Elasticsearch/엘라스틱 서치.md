# Elastic Search

> 분산 검색 엔진으로 모든 유형의 데이터를 거의 실시간으로 검색 및 분석 제공
>
> 인덱싱을 통해 빠른 검색 지원, 효율적인 색인을 제공 (페타 바이트 급의 빅데이터에 대해서 밀리세컨드 단위의 결과를 빠르게 검색 및 분석을 제공)



## ES의 특징

1. 데이터의 색인
   1. 데이터를 JSON으로 직렬화 된 형태를 저장
   2. 클러스터에 여러 노드가 있는 경우 저장된 문서가 클러스터 전체에 분산되어 모든 노드에서 접근이 가능
   3. Inverted Index 구조 지원
   4. key-value 형식으로 저장
   5. 스키마가 없는 기능도 존재 -> 처리하는 방법을 명시적으로 지정하지 않고도 데이터를 색인 할 수 있음
   6. 동적 매핑이 활성화가 되면 ES는 자동으로 새필드를 감지하고 색인함 -> 쉽게 색인과 탐색이 가능
   7. 데이터를 인덱싱하기 시작하면 ES는 소수점 및 정수, 날짜 등 감지하고 적절한 데이터 타입을 매핑
2. 데이터 검색 및 분석
   1. 아파치 루센 검색 엔진을 사용하여 전체 검색에 특화
   2. 데이터 색인및 검색하기 위해 REST API를 제공
   3. 어플리케이션단에서 원하는 언어로 엘라스틱 클라이언트를 사용할 수 있음
   4. 구조화 된 쿼리, 전체 텍스트 쿼리, 이 둘을 결합하는 복잡한 쿼리를 지원
3. 확장성
   1. 클러스터에 서버 노드를 추가하여 용량을 늘릴 수 있음
   2. 엘라스틱 서치는 사용 가능한 모든 노드에 자동으로 분산



## 색인, 인덱스, 검색, 질의

1. 색인 : 데이터가 검색될 수 있는 구조로 변경하기 위해 원본 문서를 검색어 토큰들로 변환하여 저장하는 일련의 과정
2. 인덱스 : 색인 과정을 거친 결과물, 또는 색인된 데이터가 저장되는 저장소
   * 엘라스틱 서치에서 도큐먼트들의 논리적인 집합을 표현하는 단위
3. 검색 : 인덱스에 들어있는 검색어 토큰들을 포함하고 있는 문서를 찾아가는 과정
4. 질의 : 사용자가 원하는 문서를 찾거나 집계 결과를 출력하기 위해 검색 시 입력하는 검색어 또는 검색 조건 (쿼리랑 같은 말)



### 엘라스틱 서치 클러스터 노드

* 마스터 노드
  * 인덱스의 메타 데이터, 샤드의 위치 같은 클러스터 상태 정보를 관리하는 노드
  * 클러스터마다 하나의 마스터 노드가 존재하며 마스터 노드의 역할을 수행할 수 있는 노드가 없다면 클러스터는 작동이 정지
  * 인덱스 생성/변경/삭제 등의 역할을 담당
  * 마스터 후보 노드
    * 마스터 노드로 선출 될 수 있는 마스터 후보 노드
    * 현재 마스터 역할을 수행하고 있는 노드가 네트워크상에서 끊어지거나 다운되면 다른 마스터 후보 노드 중 하나가 마스터 노드로 선출이 되어 마스터 노드의 역할을 대신 수행
    * 마스터 후보 노드들은 처음부터 마스터 노드의 정보들을 공유하고 있기 때문에 즉시 마스터 역할의 수행이 가능
  * 클러스터가 커져서 노드와 샤드들의 개수가 많아지게 되면 모든 노드들이 마스터 노드의 정보를 계속 공유하는 것은 부담이 될 수 있음
    * 이때는 마스터 노드의 역할을 수행 할 후보 노드들만 따로 설정해서 유지하는 것이 전체 클러스터 성능에 도움이 될 수 있음
    * 마스터 노드로 사용하지 않는 노드들은 설정값을 ``node.master: false``로 하여 마스터 역할을 하지 않게 함
* 데이터 노드
  * 실제로 색인된 데이터를 저장하고 있는 노드
  * 클러스터에서 마스터 노드와 데이터 노드를 분리하여 설정 할 때 마스터 후보 노드들은 ``node.data: false``ㄹㅗ 설정하여 마스터 노드 역할만 하고 데이터는 저장하지 않도록 할 수 있음
  * 이렇게 하면 마스터 노드는 데이터를 저장하지 않고 클러스터 관리만 하게 되고, 데이터 노드들은 클러스터 관리 작업으로부터 자유로워 데이터 처리에만 집중 가능
* Split Brain
  * 마스터 후보 노드를 하나만 놓게 되면 그 마스터 노드가 유실되었을 때 클러스터 전체가 작동을 정지 할 위험이 있음
  * 그래서 최소 백업용 마스터 노드를 설정하게 되는데 이 때 마스터 후보 노드들은 3개 이상의 홀수개를 놓는 것을 권장
  * 만약에 마스터 후보 노드를 2개 혹은 짝수로 운영하는 경우 네트워크 유실로 인해 다음과 같은 상황을 겪을 수 있음
    * 마스터 노드1과 마스터 노드2의 네트워크가 단절되면 서로 다른 클러스터로 구성되어 계속 동작하는 경우가 있을 수 있음
    * 이 상태에서 각자의 클러스터에 데이터가 추가 되거나 변경되고 나면 나중에 너트워크가 복구 되고 하나의 클러스터로 다시 합쳐졌을 때 데이터 정합성에 문제가 생기게 됌
    * 이 문제를 Split Brain이라 부름

* 인게스트 노드
  * 다양한 형태의 데이터를 색인할 때 데이터의 전처리를 당당하는 모드
  * 데이터를 색인할 때 간단한 포맷 변경이나 유효성 검증 같은 전처리가 필요할 때 해당 모드를 사용하면 좋음
* 코디네이트 노드
  * 사용자의 요청을 받아 처리하는 노드
  * 사용자의 요청을 데이터 노드이 검색하고 가지고 온 데이터를 취합할 때 해당 노드를 사용
  * 데이터 취합과정에서 많은 메모리를 사용하고 그리고 취합될때까지 해당 노드는 아무것도 하지 못함
    * 노드에 장애가 발생 할 수 있음
  * 따라서 별도의 클러스터 노드를 구축하면 안정적인 클러스터 운영이 가능해짐
  * 즉 정리하자면 데이터 노드는 검색 기능을 담당, 코디네이트 노드는 결과를 취합하고 요청에 응답하는 역할을 함



### 엘라스틱 서치 인덱스 & 샤드

* Example

  ```
  |0|1|2|3|4| -> 도큐먼트가 5개로 이루어진 1개의 인덱스
  
  ------    ------    ------    ------
  | 0  |    | 1  |    | 4  |    | 3  |
  |  2 |    |  4 |    |  0 |    |  1 |
  | 3  |    |    |    |    |    | 2  |
  ------    ------    ------    ------
  node1      node2     node3     node4
  
  1. 첫번째로 0이 노드에 들어가면 node1에 프라이머리 샤드로 들어감
  2. 들어가면 node3에 레플리카라는 복제본이 들어가게 됌 (반드시 다른 노드에 레플리카 생성)
  3. 이 과정을 거쳐 나머지 값도 저런 분산되어서 저장
  ```

  * 7.0버전부터 인덱스를 생성할 때 디폴트로 1개의 샤드로 인덱스가 구성, 6.x 이하 버전은 5개로 인덱스가 구성
  * 노드가 1개면 프라이머리 샤드만 존재 (레플리카 생성 x)

* 만약 노드가 유실될 경우

  ```
  Node3이 유실
  
  ------    ------    ------    ------            -------    -------    -------
  | 0  |    | 1  |    | 4  |    | 3  |            | 0   |    |  1  |    | 3 1 |
  |  2 |    |  4 |    |  0 |    |  1 |    -->     |  2  |    |   4 |    |  2  |
  | 3  |    |    |    |    |    | 2  |            | 3   |    | 0   |    |   4 |
  ------    ------    ------    ------            -------    -------    -------
  node1      node2    node3(x)   node4
  
  1. 클러스터는 처음에 node3이 복구되기 까지 기다림
  2. 타임아웃이 나거나 노드가 복구되지 않으면 엘라스틱서치는 node3에 있는 샤드를 다른 노드들이 가지고 있는 동일한 샤드를 찾아 복제
  3. 이렇게 총 10개 데이터를 유지
  
  
  ```

* 이렇게 엘라스틱 서치는 운영중에 노드가 유실되어도 데이터를 잃어버리지 않고 데이터의 가용성과 무결성을 보장



## ES 튜닝





### 인덱스 생명 주기 관리

> Hot-Warm-Cold 생명주기를 가지고 있음

* Hot : 가장 많이 검색되는 로그
* Warm : Hot 로그만큼 자주 검색되지 않지만 검색은 되는 로그
* Cold : 검색이 안되는 로그
  * Cold 노드는 선택사항이며 데이터 저장 모델에 레벨을 하나 더 제공



## ES 도구들



### 키바나

* 엘라스틱 서치와 연동되는 시각화 도구
* 검색, aggregation의 집계 기능을 이용해 엘라스틱 서치로 부터 문서, 집계 결과 등을 블러와 웹 도구로 시각화
* Discover
  * 엘라스틱 서치에 색인된 소스 데이터들의 검색을 위한 메뉴
  * 검색창에 질의문을 통해 데이터를 간편하게 검색, 필터링 할 수 있으며, 검색된 데이터의 원본 문서ㅡㄹ 확인하거나 보고 싶은 필드만 선택해서 테이블 형태로 조회가 가능
  * 시계열 기반의 로그 데이터인 경우 시간 히스토그램 그래프를 통해 시간대별 로그 수도 표시
* Visualize
  * Aggregation 집계 기능을 통해 조회된 데이터의 통걔를 다양한 차트로 표현 가능
* Dashboard
  *  visualize에서 만들어진 시가고하 도구들을 조합해서 대시보드 화면을 만들고 저장, 불러오기 등을 할 수 있는 메뉴
  *  다른 메뉴들과 마찬가지로 검색 창에 쿼리를 입력하거나 시각화 도구들을 클릭해서 조회할 데이터들의 필터링이 가능
  *  URL로 대시보드를 다른 사람들과 공유하거나 json 형식으로 내보내고 불러오기 등이 가능





### Filebeat

> Logstash를 경량하게 만든 Data Shipper

* 장점
  * CPU, RAM을 상당히 적게 소모
  * 특정한 로그타입에 대해서 모듈을 제공
  * 간단한 Filter를 제공
* 단점
  * Input, ouput이 상당히 제한적
    * input의 경우 file의 변경을 읽는 정도
    * output은 logstash, elasticsearch, kakfa, redis에 내보낼 수 있음
* 따라서 엘라스틱에 직접 전달하거나 (log자체가 json으로 남는 경우 효과적), 레디스나 카프카에 전달할때 사용하면 좋음
* 카프카와 filebeat의 시너지
  * 엘라스틱 서치가 꺼져 있을 경우 로그를 전달하지 못함
  * buffer에 담을 수 있지만 filebeat로는 한계가 있음
    * LogStash도 마찬가지 - sharding, replication을 지원하지 않음
  * 따라서 카프카를 사용해 위의 문제 해결









## Elasticsearch 용도

- 검색엔진 구현

- Application Performance Management(APM) : 어플리케이션 로그, 시스템 통계정보 분석(error, CPU/memeory usage)

- 대용량 데이터 분석

- Anomality Detection

## 특징

- 데이터는 document로 저장됨(relational database의 row와 유사함)

- document는 field로 구성(relational db의 column과 유사)

- REST API로 쿼리를 전달

- Java로 작성됨, Apache Lucene 기반

- scalable, 사용이 간편

##  Elastic Stack 구성요소
- KIBANA
- BEATS
- LOGSTASH
- X-PACK
- ELASTICSEARCH

### Kibana
- analytics & visualization platform

- elastic search 데시보드, pie chart, line chart등을 생성가능

- 실시간 웹사이트 트래픽 모니터링 가능

- 이상 현상 감지, 데이터 예측 가능

- es의 웹 인터페이스

### Logstash

- 원래는 log를 처리하고 es에 보내는 용도로 사용됨

- 최근에는 기능이 확장되어 데이터 프로세싱 용도로 사용됨

- log stash pipeline은 input,filter,output으로 구성

- horizontally scalable

### X-Pack

- es & Kibana에게 추가적인 feature 추가

- Security : authentication 과  authorization을 es와 kibana에게 제공

- Monitoring : es가 어떻게 돌고있는지에 대한 insight를 얻을수 있음. 

- Alerting : 이상현상이 발생했을때 알림기능 제공

- Reporting : 보고서를 자동으로 생성 및 이메일로 전송하는 기능제공

- Machine Learning : es와 Kibana에게 machine learning이 가능하게 함.

- Elasticsearch SQL : SQL로 es에 쿼리

### Beats

- Data Shippers

- 여러 종류의 데이터를 수집하고 es 또는 Logstash에 저장