# 카프카

## 메시징 시스템

> 문자, 이메일 같은 메세지들만 처리하는 것이 아닌 
>
> 로그 데이터, 이벤트 메시지 등 API로 호출할 때 보내는 **데이터들을 처리**하는 시스템



* Example (자동 메일 발송 시스템)

  ![img](https://t1.daumcdn.net/cfile/tistory/99C2F2345E68FF1529)

  ```
  MemberService - 회원가입했을때 이메일 발송하는 서비스
  OrderService - 주문 완료시 이메일 발송하는 서비스
  MainService - 실제 메일을 발송하는 서비스
  ```
  * 위 예제의 프로세스
    1. MemberService에서 회원가입, OrderSerivce에서 주문 완료 이벤트 발생
    2. Messaging Client에서 메일 전송에 필요한 데이터(이메일 주소, 메시지 내용 등) API 호출
    3. Messaging Client에서 MOM을 구현한 소프트웨어(kafka)로 메시지 Produce
    4. MailService에서 메시지가 존재하는지 구독하고 있다가 메시지가 존재하면 메시지를 Consume
    5. MailService에서 API 정보들을 통해 User에게 메일 발송
  * 위와 같은 구조를 publish/subscribe, producer/consumer 구조라 부름



### MOM(Message Oriented Middleware) 이란?

>  메시지 지향 미들 웨어로 독립된 애플리케이션 간에 데이터를 주고받을 수 있도록 하는 시스템 디자인

* 특징
  * 함수 호출, 공유 메모리 등의 방식이 아닌, 메시지 교환을 이용하는 중간 계층에 대한 인프라 아키택쳐 개념
  * 분산 컴퓨팅이 가능
  * 서비스간의 결합성이 적음
  * 비동기 메시지로 전달
  * Pub/Sub 구조로 이루어짐 (메시지 생산, 소비 이렇게 구성)
* Message Broker
  * 메시지 처리 또는 메시지 수신자에게 메시지를 전달하는 시스템
  * 일반적으로 MOM 기반으로 구축
* MQ (Message Queue)
  * Message Broker와 MOM을 구현한 소프트 웨어
  * MOM의 메시지 전송을 보장해야하기 때문에 AMQP를 구현
* AMQP(Advanced Message Queueing Protocol)
  * 메시지를 안정적으로 주고받기 위한 인터넷 프로토콜



### 메시징 시스템 종류와 차이

* **Kafka, RabbitMQ, ActiveMQ**의 공통점

  * 비동기 통신을 제공
  * 받는 사람, 보내는 사람 분리 (producer, consumer)

  

* **Kafka** - 특징 및 장점

  > 보통 처리량이 많은 분산 메시징 시스템에 적합

  * 확장성과 고성능 및 높은 처리량

  * 분산 시스템을 기본으로 설계 되어있기 때문에 기존 메시징 시스템에 비해 분산 및 복제 구성을 손쉽게 구축 가능

  * 대용량 실시간 로그 처리에 특화

  * AMQP나 JSM API를 사용하지 않고 단순한 메시지 헤더를 지닌 TCP기반 프로토콜을 사용
    
    * 오버헤드가 작음
    
  * 노드 장애에 대한 대응성을 가지고 있음

  * 프로듀서는 각 메시지를 배치로 브로커에게 전달

    * TCP/IP 라운드 트립을 줄임

    > TCP/IP 라운드 트립이란 클라이언트와 서버 간의 데이터 왕복 과정을 의미
    >
    > 즉 라운드 트립이 빈번하면 요청이 많다는 의미이고 이는 곧 서버 성능에 악영향을 미침
    >
    > 따라서 라운드 트립이 적게 일어나는 것이 좋음
    
  * 메시지를 기본적으로(설정 따로 x) 파일 시스템(메모리 x)에 저장
    
    * 오류 발생 시 오류점부터 복구가 가능
    
  * 메시지 파일시스템에 저장하는 구조
    
    * 메시지가 많이 쌓여도 기존 메시징 시스템에 비해 성능이 크게 감소하지 않음
    
  * Window 단위의 데이터를 넣고 꺼낼 수 있음



* **RabbitMQ** - 특징 및 장점

  > 신뢰성 있는 메시지 브로커가 필요한 경우 적합
  >
  > 물론 kafka도 신뢰성이 있지만 kafka보단 신뢰성이 높음

  * AMQT 프로토콜을 구현해 놓은 프로그램으로 빠르고 쉽게 구성이 가능하고 직관적임

  * 신뢰성, 안정성
  * 유연한 라우팅
    * MQ가 도착하기 전에 라우팅 되며 플러그인을 통해 더 복잡한 라우팅도 가능
  * 클러스터링
    * 로컬네트워크에 있는 여러 RabbitMQ 서버를 논리적으로 클러스터링 및 브로커를 할 수 있음
  * 관리 UI의 편리성
    * 관리자 페이지 및 모니터링 페이지가 제공
  * 거의 모든 언어 및 운영체제를 지원
  * 오픈소스로 상업적 지원 가능

  

* **ActiveMQ** - 특징 및 장점

  > 신뢰성 있는 메시지 브로커가 필요한 경우 적합
  
  * 자바로 만든 오픈소스 메시지 브로커
  * JMS 1.1을 통해 자바 뿐만 아니라 다른 언어를 사용하는 클라이언트도 지원
    * 다양한 언어와 프로토콜 지원
    * OpenWire를 통해 고성능 Java, C, C++, C# 클라이언트들을 지원
  * Stomp를 통해 클라이언트가 다른 인기있는 메시지 브로커들과 마찬가지로 ActiveMQ에 접근 가능
  * REST API를 통해 웹 기반 메시징 API 지원
  * 웹 브라우저가 메시징 도구가 될 수 있도록, Ajax를 통해 순수한 DHTML을 사용한 웹 스트리밍을 지원
  * Spring 지원으로 Spring Application에서는 매우 쉽게 임배딩 될 수 있음
    * XML을 통해 쉽게 설정 가능





## Kafka

> 대표적인 메시징 시스템으로 다른 구독 모델을 제공하는 분산 메세징 플랫폼

* 다른 말로 표현하면 AMQP를 구현한 MOM 시스템
* 데이터를 가지고오고 처리하는 과정을 지님



### Why Kafka?

* 분산 및 대량 처리에 특화되어 있는 도구
  * 다른 시스템의 상태 유무와 관계없이 카프카로 메시지를 보내는 역할과 받는 역할 즉 Consumer, publisher로 나뉘어져 각자 자기 역할만 수행하면 되기 때문에 분산 아키텍처에 효율적 (멀티 프로듀서, 멀티 컨슈머 관계도 가지고 있는 것도 이유중 하나)
  * 확장이 용이 -> 3대부터 수십대의 브로커로도 메시지 서버의 중지 없이 확장 가능
  * 분산처리, 배치 처리 등 다양한 기법 사용 (병렬 처리를 위한 토픽 파티셔닝 기능)
* 카프카가 빠른 이유?
  * 파일 시스템 구조를 가져와 I/O의 낮은 대기 시간
  * 큐 알고리즘을 사용해 시간 복잡도 낮춤
  * 직렬화, 역직렬화를 통해 데이터 처리
* 신뢰성
  * 다른 메시징 서비스와 달리 카프카는 디스크에 데이터를 저장하고 읽음
  * 디스크에 저장하면 일반적으로 메모리에서 읽는 것보다 느리지 않나?
    * 물론 느리긴 하지만 여기서 디스크에 읽는 것은 일반적으로 디스크에 나눠서 쓰는게 아니라 특정 영역의 디스크에 순차적으로 쓰기 때문에 읽어가는 디스크의 영역의 범위를 확 줄일 수 있어 읽어가는 속도는 조금 빠름
    * 그리고 무조건 데이터를 디스크에 쓰는 것이 아닌 VM메모리의 일부를 페이지 캐싱해서 사용하기 때문에 빠름
  * 즉 속도는 다른 MQ에 비해 느릴 수 있어도 (사실 차이는 거의 없음) 데이터를 디스크에 쓰기 때문에 데이터 유지하여 신뢰도를 높힘




### Kafka 아키텍처

![img](https://t1.daumcdn.net/cfile/tistory/99745A4B5E633AF321)

* Zookeeper
  * 클러스터의 서버들이 공유하는 데이터를 관리하기 위해 사용
  * 즉 Broker에 분산 처리된 메시지 큐의 정보들을 관리
  * Kafka를 가동하려면 Zookeeper없이 구동 불가능
* Broker
  * Kafka 서버를 의미
  * 한 클러스터 내에서 여러대 Kafka server를 구축 가능
* Topic
  * 메시지가 생산되고 소비되는 주제
  * 주제에 따라 여러 토픽 생성
  * 다수의 파티션을 가짐
* Partition
  * 토픽 내에서 메시지가 분산되어 저장되는 단위
  * 한 토픽에 파티션이 3개 있다면 3개의 파티션에 대해서 메시지가 분산되어 저장
    * 큐 방식으로 저장하고 파티션 끝에 저장이 되어 **파티션 내에서는 순서 보장**을 해주지면 **파티션끼리의 메시지 순서는 보장해주지 않음**
* 파티션은 추가만 가능(축소 x)
  * 파티션을 많이 만들면 카프카 서버가 처리해야할 메타데이터도 많아지기 때문에 성능에 영향이 있음
  
* Segement (로그 세그먼트) ([참고](https://leeyh0216.github.io/2020-05-02/kafka_concept))
  * 파티션의 한칸
  * 로그
    * 세그먼트를 구성하는 실제 데이터가 들어 있는 파일
  * 인덱스 파일
    * 파티션의 논리적인 인덱스와 파일의 물리적인 인덱스를 매핑해주는 파일
  * 타임스탬프 인덱스
* Offset
  * 파티션의 각 메시지를 식별할 수 있는 유니크한 값
    * 메시지를 소비하는 컨슈머가 읽을 차례를 의미하므로 파티션마다 별도로 관리
    * 0부터 시작하여 1씩 증가
    * 컨슈머가 어디까지 데이터를 가져갔는지 관리하기 위해 존재



### Producer, Consumer Group

![img](https://t1.daumcdn.net/cfile/tistory/998728405E6370AA1F)

* Producer
  * 정해진 토픽으로 메시지를 기록
  * Partition이 여러개 있을 경우, 기록 될 Partition의 선택은 기본적으로 **라운드 로빈 방식**을 따름
    * Partitino이 여러개 있으면 병렬 처리라는 이점이 있지만 개수는 주의해서 설정
  * 각 Partition 내에서 가장 마지막 offset 뒤에 신규 메시지가 저장되므로, Partition 내에서는 순서가 보장되며 기록
* Consumer Group
  * Consumer Group은 하나의 Topic을 담당
    * Topic 여러개의 Consumer Group에 접근 가능
  * 하나의 Partition은 Consumer Group내에 있는 하나의 Consumer Instance만 접근 가능
    * 하지만 하나의 Consumer Instance는 여러개의 partition에 소비 가능
  * Consumer Group이 왜 필요?
    * 한개의 Consumer Instance만 사용하면 해당 인스턴스 장애 발생시 작업 중단 -> 안정성 확보를 위해 존재
    * 여러개의 Consumer Instance가 한개의 Partition에 메시지를 제대로 가지고 오는지를 보장하지 못하기 때문 -> group 내에 offset을 통해 관리
  * 파티션 수와 컨슈머 그룹의 개수는 동일하거나 그룹의 개수가 파티션 개수의 반을 가지고 가는 것이 좋음 ([참고](https://www.popit.kr/kafka-consumer-group/))



### RabbitMQ vs Kafka

* RabbitMQ
  * 브로커가 컨슈머에게 메시지를 Push하는 방식
    * 브로커는 컨슈머에게 처리여부에 관계없이 Push를 하기 때문에 메시지 소비 속도보다 생산 속도가 빠를 경우 Consumer에 부하
    * RabbitMQ는 DRAM을 사용하므로 buffer를 사용하지만, DRAM을 다 사용하면 disk에 저장
      * 이는 Batch같이 큰 작업에서 disk로 메시지를 읽을 경우 지연이 발생
* Kafka
  * 컨슈머가 브로커에게 Pull하는 방식
    * 컨슈머가 처리할 수 있을 때 메시지를 가져오므로 자원을 효율적으로 사용
    * 카프카는 애초에 메시지를 디스크에 저장하고, 이미 처리한 과거의 offset으로 자유롭게 움직일 수 있음
      * 이는 Batch 작업에서 자원의 낭비라던지 지원이 발생하지 않음
      * 메시지를 쌓아놓고 처리하는 Batch Consumer 구현도 가능
  * 하지만 데이터가 없음에도 정기적인 Polling으로 인해 자원을 낭비하는 문제가 발생
    * 이는 실제 데이터가 도착할 때까지 long poll 대기를 할 수 있는 paramte를 지원





카프카 스트림즈는 앞에서 나열한 스트림 프레임워크와 달리 프레임워크위에 올라가지 않고 독립적으로 실행시키기 위한 카프카 확장 프로그램



### Replication

* 토픽을 생성할 때, --replication-factor옵션을 부여하면 복제본을 생성
* Zookeeper가 리더가 되는 파티션을 정하고 파티션을 각 브로커마다 복제를 하는 것을 말함
* 이때 리더 르 복제하느 파티션을 follower이라 함
* leader
  * 메시지를 생산하고 소비하는 작업은 모두 leader broker에서 이루어짐
* follower
  * 나머지 follower들은 leader를 복제하기만 함