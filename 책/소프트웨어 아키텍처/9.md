# Chapter 9 - 기초

아키텍처 스타일은 종종 아키텍처 패턴이라고도 부른다. 이 패턴은 통상적으로 배포 모델과 데이터 전략등 다양한 정보를 담고 있다. 따라서 아키텍트는 기초적인 아키텍처 스타일의 명칭에 익숙해져야 할것이다.



## 기초 패턴

### 진흙잡탕

진흙잡탕이란 뭐 하나 뚜렷한 아키텍처 구조가 전무한 상태를 말한다. 즉 대충 되는 대로, 아무렇게나 막 지저분하게, 테이프를 덕지덕지 붙여 놓은 스파케티 코드 정글이다.

전체적인 시스템 구조는 한번도 제대로 정의된 적이 없어, 보통 기술적으로 시각화해보면 클래스간의 강한 커플링이 많고 사소한 클래스 변경조차 다른 클래스에 미치는 연쇄적인 파급 효과를 예측하기 어렵다.

요즘에는 보통 실제 내부 구조라 할 만한 것은 하나도 없는, 데이터베이스를 직접 호출하는 이벤트 핸들러를 가진 단순한 스크립팅 애플리케이션을 가리킨다.

### 유니터리 아키텍처

유니터리 아키텍처는 소프트웨어 태동기에 주로 사용한 아키텍처로 1대의 컴퓨터에서 단일 소프트웨어를 돌아가는 것을 의미한다.

현재 유니터리 시스템은 임베디드 시스템과 그 밖에 매우 제약이 많은 극소수 환경을 제외하면 거의 쓰질 않는다. 소프트웨어 시스템은 시간이 지날수록 점점 기능이 늘어나기 마련이므로 성능, 확장 등의 운영 아키텍처 특성을 유지하려면 관심사를 분리할 필요가 있다.

### 클라이언트 / 서버

대부분의 아키텍처 스타일은 시스템에 있는 여러 부분을 효과적으로 분리하는 방법을 다룬다. 다음을 한번 보자.

* 데스크톱 + 데이터베이스 서버
  * 초창기 PC 아키텍처로 윈도우 같은 UI 기반으로 리치 데스크톱 애플리케이션을 개발하도록 지원 ( 데이터베이스 서버는 분리 )
  * 네트워크 프로토콜을 통해 접속 가능한 스탠드얼론 형태를 가짐
* 브라우저 + 웹 서버
  * 웹 브라우저가 웹 서버에 접속하는 그리고 웹 서버는 다시 데이터베이스 서버에 접속하는 형태로 분리
  * 이로써 데스크톱보다는 훨씬 가벼운 브라우저로 대체되었고 내외부 방화벽 모두 더 넓은 범위로 배포가 가능해짐
  * 데이터베이스와 서버는 같은 머신에 운용
  * 이 구조를 보통 2티어 구조라 부름
* 3티어
  * 고성능 데이터베이스 서버를 사용하는 데이터베이스 티어, 애플리케이션 서버를 관리하는 애플리케이션 티어, HTML 혹은 자바 스크립트로 이루어진 프론트 티어로 이루어진 아키텍처 구조
  * 3티어 아키텍처는 분산 아키텍처에 적합한 공통 객체 요청 브로커 아키텍처, 분산 컴포넌트 객체 모델 같은 네트워크 수준의 프로톨과 잘 맞음



## 모놀리식 대 분산 아키텍처

아키텍처 스타일은 크게 모놀리식과 분산형 두 종류이다. 

분산 아키텍처 스타일은 모놀리식 아키텍처 스타일에 비해 성능, 확장성, 가용성 측면에서 훨씬 강력하지만, 다음과 같은 8가지 오류가 적용된다.

### 오류 #1 : 네트워크는 믿을 수 있다.

분산 아키텍처는 특성상 서비스를 오가는, 또 서비스 간에 이동하는 네트워크에 의존한다, 그렇기 때문에 네트워크에 문제가 발생하면 처리할 수 없어 시스템 장애를 일으킬 수 있다.

따라서 시스템이 네트워크에 더 의존할수록 시스템의 신뢰도는 잠재적으로 떨어질 가능성이 있다.

### 오류 #2 : 레이턴시는 0이다.

모든 분산 아키텍처는 레이턴시가 0이 아니다. 

특히 MSA는 서비스가 잘게 나뉘기 때문에 서비스간 통신량이 많다. 한개의 처리 레이턴시가 평균 60밀리초에 불과한다 해도 100번 나눠 부르면 400밀리초가 될 수도 있다. 따라서 평균 레이턴시도 중요하지만 백분위수를 이해하는 것이 더 중요하다.

### 오류 #3 : 대역폭은 무한하다.

모놀로식은 별로 문제될 것이 없지만, 마이크로서비스는 서비스들 간에 주고받는 통신이 대역푝을 상당히 점유하면 네트워크가 느려지고, 결국 레이턴시와 신뢰성에도 영향을 미친다.

예를 들면 A서비스에서 B서비스에 데이터를 요청시 500kb라는 대역폭을 사용한다 해보자. 이중 A서비스는 응답받은 데이터중 200byte만 사용할 경우 나머지 498바이트는 의미가 없이 사라진다. 그리고 이 요청을 1초에 2000번 정도 발생시킨다면 무려 1GB라는 대역폭을 의미없이 낭비시켜버려 레이턴시가 커지게 된다.

 이를 스탬프 커플링이라 부르는데 다음과 같이 해결할 수 있다.

* 프라이빗 REST API 엔드포인트를 둔다.
* 계약에 필드 셀렉터를 사용한다.
* GraphQL로 계약을 분리한다.
* 컨슈머 주도 계약와 값 주도 계약을 병용한다.
* 내부 메시징 엔드포인트를 사용한다.

어떤 기법을 적용하든, 분산 아키텍처의 서비스 또는 시스템 간에 최소한의 데이터만 주고받도록 하는 것이 이 오류를 바로잡는 최선의 길이다.

### 오류 #4 : 네트워크는 안전한다.

보안은 분산 아키텍처에서 어려운 문제이다.

각 엔드포인트마다 악의적인 요청이 들어오지 않도록 막아야 하고 보안 대책을 강구해야 한다. 

모든 엔드포인트에, 서비스 간 통신에도 보안이 적용돼야 하므로 마이크로서비스나 서비스 기반 아키텍처처럼 고도로 분산된 동기 아키텍처에서 당연히 성능이 떨어질 수 밖에 없다.

### 오류 #5 : 토폴로지는 절대 안 바뀐다.

네트워크를 구성하는 모든 라우터, 허브,스위치, 방화벽, 네트워크, 어플라이언스(하드웨어, 운영체제, 소프트웨어가 이미 설치되어 세팅 완료 제품)등 전체 네트워크 토폴로지가 불변일거란 생각에 오류를 발생시킨다.

따라서 아키텍트 운영자, 네트워크 관리자와 항시 소통을 하면서 무엇이, 언제 변경되는지 알고 있어야 한다.

### 오류 #6 : 관리자는 한 사람뿐이다.

아키텍트는 언제나 한사람의 관리자와만 협의하고 소통하면 다양한 오류에 봉착하더라도 해결할 수 없을 수 있다. 이러한 문제의 원인은 다양한 분야의 관리자들과 소통이 안되 생기는 문제라 볼 수 있다.

모놀로식은 단일 단위로 배포하기 때문에 많은 소통이 필요 없을 수 있지만 MSA는 복잡할 수 밖에 없기 때문에 많은 조율이 필요하다.

### 오류 #7 : 운송비는 0이다.

여기서 말하는 운송비는 단순한 REST 호출을 하는데 소요되는 진짜 비용을 말한다. (레이턴시가 아니다.)

즉 아키텍트는 용량, 대역폭, 레이턴시, 보안 구역 측면에서 현대의 서버와 네트워크 토폴로지를 철저히 분석하여 착각의 늪에 빠지지 않도록 해야 한다.

### 오류 #8 : 네트워크는 균일하다

온갖 종류의 하드웨어가 서로 다 잘 맞물려 동작하는 것은 아니다. 이를 간과하면 네트워크 패킷이 유실되거나 네트워크 신뢰성, 레이턴시, 대역폭 등 차례대로 영향을 받을 수 있다.

그렇기 때문에 아키텍트는 여러 업체의 네트워크 하드웨어 제품들을 파악하여 관리할 수 있어야 한다.

### 다른 분산 아키텍처 고려 사항

* 분상 로깅
  * 분산 아키텍처에서 로그 관리는 어렵고 시간도 많이 걸린다. ( 위치가 제각각, 포멧도 제각각 )
  * 따라서 스플렁크 같은 로깅 통합 도구를 사용해 어느정도 해결할 수 있지만, 분산 로그 관리를 제대로 하기에는 어렵다.
* 분산 트랜잭션
  * 모놀로식은 트랜잭션 관리를 쉽게 할 수 있다. ( 트랜잭션을 걸어 업데이트시 데이터 일관성과 무결성을 강제 시킴 )
  * 하지만 분산 아키텍처는 일관성을 파악하고 트랜잭션을 거는 것이 어렵다.
  * 분산 아키텍처는 최종 일관성이라는 개념을 바탕으로 별도로 분리된 배포 단위에서 처리된 데이터를 미리 알 수 없는 어느 시점에 모두 일관된 상태로 동기화한다.
  * 분산 트랜잭션을 관리하는 한 가지 방법으로 트랜잭셔널 사가가 있느다.
    * 트랜잭션 사가는 보상을 위해 이벤트 소싱하거나 트랜잭션 상태를 관리하기 위해 유한 상태 기계를 활용한다.
* 계약 관리 및 버저닝
  * 계약은 클라이언트와 서비스 모두 합의한 행위와 데이터이다.
  * 분산은 아키텍처에서는 분리된 서비스와 시스템을 제각기 다른 팀과 부서가 소유하기 때문에 계약 유지보수가 특히 어렵다.
