# Chapter 14 -이벤트 기반 아키텍처 스타일



## 토폴로지

이벤트 기반 아키텍처는 비동기 분한 아키텍처 스타일로서 소규모나 대규모 애플리케이션에 두루두루 사용할 수 있는 아키텍처 스타일이다.

이벤트 기반 아키텍처는 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트들로 구성되며, 스탠드얼론 아키텍처 스타일로 사용하거나 다른 아키텍처 스타일에 내장할 수도 있다.

애플리케이션은 대부분 요청 기반 모델을 따르고, 이 모델은 어떤 액션을 수행하도록 시스템에 요청하면(요청 프로세스) 요청 오케스트레이터라는 곳에서 접수해 처리하게 된다. 또한 요청 오케스트레이터는 보통 유저 인터페이스이지만 API레이어나 엔터프라이즈 서비스로도 구현할 수 있다. 또한 요청 프로세스는 요청을 받아 데이터베이스에서 정보를 조회/수정하는 등의 작업을 수행한다.

이벤트 기반 주요 토폴로지는 ``중재자 토폴로지``와 ``브로커 토폴로지``가 있다. 주로 중재자 토폴로지는 이벤트 처리 워크플로를 제어해야 할 경우에 사용하고 브로커 토폴로지는 신속한 응답과 동적인 이벤트 처리 제어가 필요할 때 각각 사용한다.



## 브로커 토폴로지

브로커 토폴로지의 특징은 다음과 같다.

1. 메시지는 경량 메시지 브로커를 통해 브로드캐스팅이 되는 식
2. 이벤트 처리 흐름이 단순하고 굳이 중앙에서 이벤트를 조정할 필요가 없을 때 유용
3. 구성
   1. 시작 이벤트
      * 전체 이벤트 흐름을 개시하는 이벤트를 말함
      * 이벤트 브로커의 이벤트 채널로 전송되어 처리
   2. 이벤트 브로커
      * 시작 이벤트를 받아 관련된 처리 작업을 진행
      * 필요시 부가적인 처리를 위해 처리 이벤트를 다른 이벤트 브로커에 비동기 전송하기도 함
   3. 이벤트 프로세서
      * 처리 이벤트를 리스닝하고 있다가 이벤트가 들어오면 그에 맞는 작업을 수행 및 처리 이벤트 생성
      * 이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 일림
   4. 처리 이벤트
      * 작업을 수행하는 이벤트
4. 이벤트 브로커 컴포넌트는 보통 연합체로 구성
   * 연합된 각 브로커에서는 주어진 도메인 이벤트 흐름에서 사용되는 모든 이벤트 채널이 들어 있음
5. 브로커 토폴로지에서는 다른 이벤트 프로세서의 관심 여부와 무관하게 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는게 항상 바람직함 ( 확장성이 쉬움 )

브로커 토폴로지의 가장 중요한 점은 이벤트 프로세설는 이벤트 전달 후 더 이상 그 이벤트 처리에 관여하지 않고 다른 시작 이벤트 또는 처리 이벤트에 반응할 중비를 하는 것이다.

또한 각 이벤트 프로세서는 이벤트 처리 도중 가변적인 부하나 백업 조건을 처리하기 위해 서로 독립적으로 확장할 수 있다.

브로커 토폴로지의 장단점은 다음과 같다.

| 장점                         | 단점                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 이벤트 프로세서가 디커플링됨 | 워크플로 제어가 어려움 (트랜잭션 관리, 시스템 유동성 등)     |
| 확장성이 높음                | 에러 처리가 어려움                                           |
| 응답성이 우수함              | 트랜잭션을 재시작하는 기능 / 복구성이 지원되지 않음( 상태를 모르기 때문에 ) |
| 성능이 우수함                | 재시작 능력이 떨어짐 (비동기의 폐해)                         |
| 내고장성이 뛰어남            | 데이터 비일관성 위험이 높음                                  |



## 중재자 토폴로지

중재자 토폴로지의 특징은 다음과 같다.

1. **워크플로 관리/제어하는 이벤트 중재자가 있음 (핵심)**
   * **이는 워크플로에 대해 잘 알고 있고 통제가 가능**
   * **또한 워크플로를 제어하므로 이벤트 상태를 유지하면서 필요시 에러 처리, 복구, 재시작이 가능**
2. 구성
   1. 시작 이벤트
      * 전체 이벤트 프로세스를 개시
      * 브로커 토폴로지와 차이점은 시작 이벤트 큐를 거쳐 이벤트 중재자로 이벤트가 들어옴
   2. 이벤트 큐
      * 이벤트 대기열
   3. 이벤트 중재자
      * 이벤트 처리에 관한 단계 정보만 갖고 있음
      * 점대점 메시징으로 각각의 이벤트 채널로 전달하는 처리 이벤트를 생성
   4. 이벤트 채널
      * 처리 이벤트를 담는 곳
   5. 이벤트 프로세서
      * 자신의 이벤트 채널에서 이벤트를 받아 처리한 다음 중재자에게 작업을 완료했다고 응답
      * 브로커 토폴로지와 차이점은 이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 알리지 않음
3. 중재자 토폴로지 구현체에는 대부분 특정 도메인이나 이벤트 그룹과 연관된 중재자가 여럿 존재
   * 즉 토폴로지의 단일 장애점을 줄이고 전체 처리량과 성능 향상
4. 이벤트 중재자 처리하는 이벤트의 특성과 복잡도에 따라 다양한 방법으로 구현 가능
   * ex) 아파치 카멜, 뮬 ESB, 스프링 인티그레이션 등의 중재자
   * 보통 이런 중재자는 이벤트 워크플로를 프로그래밍 코드로 제어

알맞은 이벤트 중재자 구현체를 선택하려면 먼저 중재자를 통해 어떤 종류의 이벤트 처리를 할 것인지 생각해야 한다. 그리고 이벤트 복잡도를 한 가지 기준으로 평가하는 경우는 거의 없으므로 알기 쉽게 단순함, 어려움, 복잡함 정도로 분류한 뒤 모든 이벤트가 항상 단순한 중재자를 거치도록 하는 것이 좋다.

중재자 토폴로지의 장단점은 다음과 같다.

| 장점                                   | 단점                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| 워크플로 제어가 가능                   | 이벤트 처리를 중재자가 제어하므로 이벤트 프로세서가 상대적으로 더 많이 커플링됨 |
| 에러 처리가 가능                       | 중재자도 함께 확장해야 하므로 확장성이 낮음                  |
| 복구성이 뛰어남                        | 성능이 낮음                                                  |
| 재시작 능력이 브로커 토폴로지보다 좋음 | 내고장성이 좋지 않음                                         |
| 데이터 일관성                          | 복잡한 이벤트 흐름 내에서 발생하는 동적인 처리를 선언적으로 모델링하기가 매우 어려움<br />(주로 내부 워크플로는 일반적인 처리만하고 복잡한 이벤트 처리는 중재자 + 브로커 형태의 하이브리드 모델로 처리) |



 ## 비동기 통신

이벤트 기반 아키텍처 스타일은 요청/응답 뿐만 아니라 파이어 앤드 포겟 처리 모두 비동기 통신만 사용해야 한다는 특징이 있다. 이는 시스템 응답성을 전반적으로 높이는 강력한 기법으로 활용할 수 있다.

예를 들면 동기 처리에서는 3000m/s로 응답 받을 일을 비동기 통신으로 25m/s 만에 처리 할 수 있다는 것이다.

하지만 비동기 호출에는 단점이 있다. 바로 에러 처리이다. 응답성은 엄청나게 개선되지만 에러를 제대로 처리하기가 쉽지 않기 때문에 복잡도가 가중된다.



## 에러 처리

비동기 통신 에러 처리에 있어 `리엑티브 아키텍처의 워크플로 이벤트 패턴`을 사용하면 해결할 수 있다. 리엑티브 아키텍처 워크플로 이벤트 패턴이란 **시스템을 응답성에 영향을 미치지 않고 탄력적으로 에러를 처리할 수 있게 만드는 패턴**이다.

이 패턴은 다음과 같이 수행한다.

1. 이벤트 프로듀서는 메시지 채널을 통해 데이터를 이벤트 컨슈에러가 발생하면 즉시 해당 에러를 워크플로 프로머에게 비동기 전송

2. 이벤트 컨슈머가 데이터를 처리하는 도중 해당 에러를 워크플로 프로세서에게 **위임**하여 **봉쇄**시킨 뒤 다음 메시지로 넘어감

   * 이렇게 하면 에러가 발생해도 다음 메시지를 바로 처리하므로 전체 응답성은 영향을 받지 않음

3. 에러를 수신한 워크플로 프로세서는 메시지에 뭐가 잘못됐는지 확인

4. 확인 후 원데이터를 변경해서 긴급 **수리** 후 원래 큐로 돌려보낸 후 재처리

   * 만약 끝까지 에러를 해결하지 못하는 경우가 있기 때문에 대시보드가 확인하는 메시지 큐로 보냄

   * 담당자는 직접 메시지를 확인하고 조치

즉 대리자를 통해 위임, 봉쇄, 수리 작업을 진행하는 구조이다.

워크플로 이벤트 패턴을 적용하면 프로그래밍 방식으로 에러를 조치할 수 있다. 다만 한가지 주의할 점은, 에러가 발생한 메시지를 조치 후 다시 제출하면 처리 순서가 바뀐다. 이를 유지하는 것은 매우 복잡한 작업이기 때문에 많은 고민을 통해 해결하는 것이 중요하다.



## 데이터 소실 방지

이벤트 기반 아키텍처는 데이터가 소실될 만한 곳이 엄청 많다. 여기서 말하는 데이터 소실이란 메시지가 도중에 삭제되거나 최종 목적지에 도달하지 못한 상태를 말한다. 

데이터 소실 방지 문제는 기본적인 메시징으로 어느 정도 해결할 수 있다. 다음 데이터 소실이 일어나는 몇가지 경우와 해결 방법을 나열해보겠다.

1. 이벤트 프로세서 A에서 메시지가 큐로 전달되지 않거나, 아니면 전달되어도 다음 이벤트 프로세서가 메시지를 가져오기 전에 브로커가 다운
   * 해결 방법 - ***동기 전송과 퍼시스턴트 메시지 큐를 이용***
     * **퍼시스턴트 메시지 큐**는 메시지를 물리적 데이터 저장소에 저장하여 문제가 발생되도 데이터 소실 없이 처리 할 수 있는 방법 
     * **동기 전송**은 브로커가 메시지를 저장했다고 확인 응답을 줄 때까지 메시지 프로듀서를 차단하여 기다리게 하는 방법
2. 이벤트 프로세서 B가 큐에서 다음 메시지를 꺼내 이벤트를 처리하기 전에 장애가 발생
   * 해결 방법 - **클라이언트 확인 응답 모드라는 기본적인 메시징 기술을 이용**
     * **클라이언트 확인 응답 모드**는 메시지를 큐에 보관한 채 다른 컨슈머가 메시지를 읽을 수 없게 클라이언트 ID를 메시지에 부착
     * 이는 프로세서 B가 잘못되더라도 데이터는 큐에 계속 남아 있으니 데이터 소실 방지
3. 데이터 에러로 인해 이벤트 프로세서 B가 데이터베이스에 메시지를 저장하지 못함
   * 해결 방법 - **ACID 트랜잭션의 커밋으로 해결**
     * 데이터베이스는 커밋이 일어나면 확실하게 데이터 저장
     * 데이터베이스에 저장됐음을 확인한 이후에 큐에서 메시지 삭제



## 브로드캐스팅

이벤트 기반 아키텍처는 이젠트를 브로드캐스트 할 수 있다. 이는 여러 이벤트 프로세서를 가장 높은 수준으로 디커플링하는 수단이며, 최종 일관성, 복잡한 이벤트 처리등 다양한 쓰임새를 지닌다.



## 요청-응답

이벤트 기반 아키텍처는 동기 통신을 요청-응답 메시징 방식으로 수행한다. 요청-응답 메시징 내부의 각 이벤트 채널은 요청 큐, 응답 큐로 구성된다.

실행 방식은 다음과 같다.

1. 처음 정보를 요청하면 요청 큐에 비동기 전송 후 메시지 프로듀서에게 제어권이 반환
2. 이때 메시지 프로듀서는 응답 큐에 응답이 도착하길 기다리고 차단 대기 상태로 변경
3. 메시지를 받아 처리한 후 응답 큐에 응답을 보내면 이벤트 프로듀서는 응답 데이터가 포함된 메시지를 수신

메시징을 구현하는 주요한 기술은 다음과 같다.

1. 메시지 헤더에 상관 ID를 사용 ( 일반적인 기술이고 많이 사용하고 권장하는 기술 )
   * 상관 ID : 응답 메시지의 필드로, 대부분 원요청 메시지의 메시지 ID로 세팅
2. 응답 큐에 임시 큐를 두고 요청-응답 메시징을 구현하는 방법
   * 임시 큐는 지정된 요청에만 사용되는데, 요청이 들어오면 생성되고 요청이 종료되면 삭제

임시 큐 방법이 훨씬 단순하지만 메시지 브로커는 매번 요청을 할 때마다 임시 큐를 생성/폐기하는 일을 반복해야 하기 때문에 대용량 메시지 처리 시 메시지 브로커의 속도가 크게 떨어지고 전체 성능과 응답성 역시 영향을 받을 수 있다.



## 요청 기반이냐, 이벤트 기반이냐

* 우수성 표

|                             | 요청 기반 | 이벤트 기반 |
| --------------------------- | --------- | ----------- |
| 동적인 유저 콘텐츠의 응답성 | 나쁨      | 좋음        |
| 확장성, 탄력성              | 덜 우수   | 우수        |
| 민첩성과 변화 관리          | 덜 우수   | 우수        |
| 적응성과 확장성             | 나쁨      | 좋음        |
| 응답성과 성능               | 나쁨      | 좋음        |
| 실시간 의사 결정            | 어려움    | 쉬움        |
| 상황 인지에 따른 반응성     | 나쁨      | 좋음        |
| 최종 일관성 지원            | 쉬움      | 어려움      |
| 처리 흐름 제어              | 쉬움      | 어려움      |
| 이벤트 흐름의 결과 예측     | 쉬움      | 어려움      |
| 테스트, 디버깅              | 쉬움      | 어려움      |

즉 워크플로의 확장성과 제어가 중요하면 **체계적인 데이터 기반의 요청에 특화된 요청 기반** 모델을, 복잡하고 동적인 유저 처리 등 주로 고도의 응답성과 확장성을 요하는 **유연한 액션 단위의 이벤트를 처리한다면 이벤트 기반 모델**이 좋다.



## 하이브리드 이벤트 기반 아키텍처

하이브리드 이벤트 기반 아키텍처는 다양하게 사용될 수 있다. 대표적으로 공간 기반 아키텍처나 마이크로서비스 아키텍처가 있다.

어떤 아키텍처 스타일이든지 이벤트 기반 아키텍처를 추가하면 병목 지점을 제거하고 이벤트 요청을 백업하는 배압 지접을 확보하는데 유용하며, 다른 아키텍처 스타일에서는 찾아볼 수 없는 유저 응답성이 보장된다.



## 아키텍처 등급

| 아키텍처 특성 | 별점                           | 설명                                                         |
| ------------- | ------------------------------ | ------------------------------------------------------------ |
| 분할 유형     | 기술                           | 특정 도메인이 여러 이벤트 프로세서에 분산되어 있고 중재자, 큐, 토픽을 통해 서로 묶여 있는, 기술 분할 아키텍처 |
| 퀀텀 수       | 한개 또는 여러 개              | 각 이벤트 프로세서의 데이터베이스 상호작용 및 요청-응답 처리를 기반으로 하므로 퀀텀 수는 1개 이상 |
| 배포성        | :star::star::star:             |                                                              |
| 탄력성        | :star::star::star:             |                                                              |
| 진화성        | :star::star::star::star::star: | 고도로 진화적 (새로운 기능을 추가하는 것이 간단)             |
| 내고장성      | :star::star::star::star::star: | 워크플로의 최종 이관성 및 최종 처리를 제공하는 고도로 분리된 비동기 이벤트 프로세서를 활용 |
| 모듈성        | :star::star::star::star:       |                                                              |
| 전체 비용     | :star::star::star:             |                                                              |
| 성능          | :star::star::star::star::star: | 이벤트 프로세서를 추가해서 장가된 요청을 처리                |
| 신뢰성        | :star::star::star:             |                                                              |
| 확장성        | :star::star::star::star::star: | 로드 밸런싱이 가능                                           |
| 단순성        | :star:                         | 비결정적, 동적인 이벤트 흐름                                 |
| 시험성        | :star::star:                   | 비결정적, 동적인 이벤트 흐름                                 |
