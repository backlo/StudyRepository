# Chapter 14 -이벤트 기반 아키텍처 스타일



## 토폴로지

이벤트 기반 아키텍처는 비동기 분한 아키텍처 스타일로서 소규모나 대규모 애플리케이션에 두루두루 사용할 수 있는 아키텍처 스타일이다.

이벤트 기반 아키텍처는 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트들로 구성되며, 스탠드얼론 아키텍처 스타일로 사용하거나 다른 아키텍처 스타일에 내장할 수도 있다.

애플리케이션은 대부분 요청 기반 모델을 따르고, 이 모델은 어떤 액션을 수행하도록 시스템에 요청하면(요청 프로세스) 요청 오케스트레이터라는 곳에서 접수해 처리하게 된다. 또한 요청 오케스트레이터는 보통 유저 인터페이스이지만 API레이어나 엔터프라이즈 서비스로도 구현할 수 있다. 또한 요청 프로세스는 요청을 받아 데이터베이스에서 정보를 조회/수정하는 등의 작업을 수행한다.

이벤트 기반 주요 토폴로지는 ``중재자 토폴로지``와 ``브로커 토폴로지``가 있다. 주로 중재자 토폴로지는 이벤트 처리 워크플로를 제어해야 할 경우에 사용하고 브로커 토폴로지는 신속한 응답과 동적인 이벤트 처리 제어가 필요할 때 각각 사용한다.



## 브로커 토폴로지

브로커 토폴로지의 특징은 다음과 같다.

1. 메시지는 경량 메시지 브로커를 통해 브로드캐스팅이 되는 식
2. 이벤트 처리 흐름이 단순하고 굳이 중앙에서 이벤트를 조정할 필요가 없을 때 유용
3. 구성
   1. 시작 이벤트
      * 전체 이벤트 흐름을 개시하는 이벤트를 말함
      * 이벤트 브로커의 이벤트 채널로 전송되어 처리
   2. 이벤트 브로커
      * 시작 이벤트를 받아 관련된 처리 작업을 진행
      * 필요시 부가적인 처리를 위해 처리 이벤트를 다른 이벤트 브로커에 비동기 전송하기도 함
   3. 이벤트 프로세서
      * 처리 이벤트를 리스닝하고 있다가 이벤트가 들어오면 그에 맞는 작업을 수행 및 처리 이벤트 생성
      * 이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 일림
   4. 처리 이벤트
      * 작업을 수행하는 이벤트
4. 이벤트 브로커 컴포넌트는 보통 연합체로 구성
   * 연합된 각 브로커에서는 주어진 도메인 이벤트 흐름에서 사용되는 모든 이벤트 채널이 들어 있음
5. 브로커 토폴로지에서는 다른 이벤트 프로세서의 관심 여부와 무관하게 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는게 항상 바람직함 ( 확장성이 쉬움 )

브로커 토폴로지의 가장 중요한 점은 이벤트 프로세설는 이벤트 전달 후 더 이상 그 이벤트 처리에 관여하지 않고 다른 시작 이벤트 또는 처리 이벤트에 반응할 중비를 하는 것이다.

또한 각 이벤트 프로세서는 이벤트 처리 도중 가변적인 부하나 백업 조건을 처리하기 위해 서로 독립적으로 확장할 수 있다.

브로커 토폴로지의 장단점은 다음과 같다.

| 장점                         | 단점                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 이벤트 프로세서가 디커플링됨 | 워크플로 제어가 어려움 (트랜잭션 관리, 시스템 유동성 등)     |
| 확장성이 높음                | 에러 처리가 어려움                                           |
| 응답성이 우수함              | 트랜잭션을 재시작하는 기능 / 복구성이 지원되지 않음( 상태를 모르기 때문에 ) |
| 성능이 우수함                | 재시작 능력이 떨어짐 (비동기의 폐해)                         |
| 내고장성이 뛰어남            | 데이터 비일관성 위험이 높음                                  |



## 중재자 토폴로지

중재자 토폴로지의 특징은 다음과 같다.

1. **워크플로 관리/제어하는 이벤트 중재자가 있음 (핵심)**
   * **이는 워크플로에 대해 잘 알고 있고 통제가 가능**
   * **또한 워크플로를 제어하므로 이벤트 상태를 유지하면서 필요시 에러 처리, 복구, 재시작이 가능**
2. 구성
   1. 시작 이벤트
      * 전체 이벤트 프로세스를 개시
      * 브로커 토폴로지와 차이점은 시작 이벤트 큐를 거쳐 이벤트 중재자로 이벤트가 들어옴
   2. 이벤트 큐
      * 이벤트 대기열
   3. 이벤트 중재자
      * 이벤트 처리에 관한 단계 정보만 갖고 있음
      * 점대점 메시징으로 각각의 이벤트 채널로 전달하는 처리 이벤트를 생성
   4. 이벤트 채널
      * 처리 이벤트를 담는 곳
   5. 이벤트 프로세서
      * 자신의 이벤트 채널에서 이벤트를 받아 처리한 다음 중재자에게 작업을 완료했다고 응답
      * 브로커 토폴로지와 차이점은 이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 알리지 않음
3. 중재자 토폴로지 구현체에는 대부분 특정 도메인이나 이벤트 그룹과 연관된 중재자가 여럿 존재
   * 즉 토폴로지의 단일 장애점을 줄이고 전체 처리량과 성능 향상
4. 이벤트 중재자 처리하는 이벤트의 특성과 복잡도에 따라 다양한 방법으로 구현 가능
   * ex) 아파치 카멜, 뮬 ESB, 스프링 인티그레이션 등의 중재자
   * 보통 이런 중재자는 이벤트 워크플로를 프로그래밍 코드로 제어

알맞은 이벤트 중재자 구현체를 선택하려면 먼저 중재자를 통해 어떤 종류의 이벤트 처리를 할 것인지 생각해야 한다. 그리고 이벤트 복잡도를 한 가지 기준으로 평가하는 경우는 거의 없으므로 알기 쉽게 단순함, 어려움, 복잡함 정도로 분류한 뒤 모든 이벤트가 항상 단순한 중재자를 거치도록 하는 것이 좋다.

중재자 토폴로지의 장단점은 다음과 같다.

| 장점                                   | 단점                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| 워크플로 제어가 가능                   | 이벤트 처리를 중재자가 제어하므로 이벤트 프로세서가 상대적으로 더 많이 커플링됨 |
| 에러 처리가 가능                       | 중재자도 함께 확장해야 하므로 확장성이 낮음                  |
| 복구성이 뛰어남                        | 성능이 낮음                                                  |
| 재시작 능력이 브로커 토폴로지보다 좋음 | 내고장성이 좋지 않음                                         |
| 데이터 일관성                          | 복잡한 이벤트 흐름 내에서 발생하는 동적인 처리를 선언적으로 모델링하기가 매우 어려움<br />(주로 내부 워크플로는 일반적인 처리만하고 복잡한 이벤트 처리는 중재자 + 브로커 형태의 하이브리드 모델로 처리) |

