# Chapter 13 - 서비스 기반 아키텍처 스타일

## 토폴로지

서비스 기반 아키텍처는 각각 따로 배포된 유저 인터페이스와 원격 서비스, 모놀리스 데이터베이스로 이루어진 대규모 분산 레이어 구조이다. 단일 모놀로식 데이터베이스 역시 개별 데이터베이스로 분리할 수 있고 (MSA 처럼) 각 도메인 서비스 전용 데이터베이스로 쪼갤 수도 있다.

**여기서 중요한건 각 데이터베이스에 있는 도메인 데이터를 다른 도메인의 서비스가 필요로 하지 않도록 설계하는 것이다.**

그렇게 해야 도메인 서비스 간 상호 통신을 방지하고, 중복 데이터도 피할 수 있다.



## 서비스 설계 및 세분도

서비스 기반 아키텍처의 도메인 서비스는 모듈러 모놀리스 아키텍처 스타일처럼 서브 도메인을 이용해 각 도메인 서비스를 분할하는 방법을 사용할 수도 있지만 보통 단위가 크기 때문에 도메인 서비스를 **퍼사드 레이어, 비지니스 레이어, 퍼시스턴스 레이어**로 구성된 레이어드 아키텍처로 설계하는 것이 일반적이다. 

다음은 서비스 기반 아케틱처의 큰 특징을 보려고 한다.

### 1. API 액세스 퍼사드

유저 인터페이스를 통해 유입된 비즈니스 요청을 오케스트레이트하는 역할을 한다. 

마이크로서비스와 비교했을 내부 클래스 수준의 오케스트레이션과 외부 서비스의 오케스트레이션이라는 차이를 가지고 있다.

### 2. 도메인 서비스

세분도가 큰 까닭에 단일 도메인 서비스에서 데이터 무결성을 보장하기 위해 커밋/롤백이 수반되는 여느 ACID 데이터베이스 트랜잭션을 사용한다.

여기서 포인트는 서비스 기반 아키텍처는 ACID를 트랜잭션을 사용하지만, 마이크로서비스처럼 분산도가 높은 아키텍처는서비스를 더 잘게 나누기 때문에 BASE 트랜잭션 ( 가용성, 소프트 상태, 최종 일관성) 이라고 알려진 분산 트랜잭션 기법을 사용한다. 이는 서비스가 잘게 나뉘어진 탓에 비즈니스 프로세스를 오케스트레이트를 정밀하게 해야하는 트레이드 오프를 가지고 있다.

하지만 서비스 기반 아키텍처의 도메인 서비스 단위가 커서 가지는 문제들도 많다. 

1. 서비스 기반 아키텍처는 단위가 크기 때문에 변경된 곳이 있으면 전체 서비스를 테스트 해야한다는 것이다.
2. 서비스 기반 아키텍처는 코드가 점점 더 많이 배포 될 수록 뭔가 문제를 일으킬 소지가 커진다는 것이다.



## 데이터베이스 분할

서비싀 기반 아키텍처의 서비스는 주어진 애플리케이션 콘텍스트에서 서비스 수가 적은 편이라서 보통 단일 모놀리식 데이터베이스를 공유한다. **그러나 이러한 데이터베이스 커플링은 테이블 스키마 변경 시 문제가 될 수 있다.**

데이터 리소스를 사용하기 위해 보통 커스텀 공유 라이브러리를 사용하는 방법을 생각할텐데 이는 가장 비효율적인 구현 방법이다. 그 이유는 테이블 구조가 조금이라도 변경할 일이 있으면 변경된 테이블의 사용 여부와 상관 없이 전체 서비스를 일제히 변경 후 재배포할 수 밖에 없기 때문이다.

데이터베이스 변경 영향도와 리스크를 낮추는 한 가지 방법은, **데이터베이스를 논리적으로 분할하고 이러한 논리 분할을 연합 공유 라이브러리를 통해 명시하는 것이다.** 이런 식으로 구성하면, 특정 논리 도메인에 속한 테이블을 변경해도 해당 엔티티 객체가 포함된 해당 공유 라이브러리를 사용하는 서비스만 영향 받을 뿐, 그 밖의 서비스에는 영향을 받지 않는다. 그리고 공통 도메인을 변경시 공유 데이터베이스를 액세스하는 전체 서비스를 미리 조율해야한다.



## 언제 이 아키텍처 스타일을 사용하는가

이 아키텍처 스타일은 유연성 때문에 가장 실용적인 아키텍처이다. 도메인 주도 설계와 궁합이 잘 맞고 다른 분산 아키텍처에 비해 ACID 트랜잭션이 더 잘 보존된다.

유저 인터페이스나 API 게이트웨이가 둘 이상의 도메인 서비스를 오케스트레이션하는 경우도 있는데, 이럴 때에는 트랜잭션이 SAGA와 BASE 트랜잭션에 의존해야한다. 그러나 대부분 트랜잭션은 특정 도메인 서비스에 한정되므로 거의 모든 모놀리식 애플리케이션에서 찾아볼 수 있는 전통적인 커밋/롤백 트랜잭션 기능은 그대로 가능하다.



## 아키텍처 특성 등급

| 아키텍처 특성 | 별점                     | 설명                                                         |
| ------------- | ------------------------ | ------------------------------------------------------------ |
| 분할 유형     | 도메인                   | 기술 관심사보다 도메인을 위주로 구성                         |
| 퀀텀 수       | 한개 또는 여러 개        | 분산 아키텍처이므로 퀀텀은 1개 이상 ( 만약 동일한 데이터베이스나 유저 인터페이스를 공유할 경우 퀀텀수 1개) |
| 배포성        | :star::star::star::star: | 덩치 큰 모놀리스보다 덜 위험하게, 더 자주 배포 가능          |
| 탄력성        | :star::star:             | 서비스를 나누는 단위가 큼 (중복되는 기능이 많음)             |
| 진화성        | :star::star::star:       |                                                              |
| 내고장성      | :star::star::star::star: | 도메인 서비스는 보통 굵직굵직하게 나누지만 서비스 기반 아키텍처의 서비스는 자기 완비형, 데이터 베이스와 코들를 공유하기 때문에 통신이 거의 없음 |
| 모듈성        | :star::star::star::star: | 복잡하게 뒤얽히거나 세분도의 함정에 빠져 허우적거리지 않고도 아키텍처 모듈성을 괜찮은 수준으로 달성 |
| 전체 비용     | :star::star::star::star: | 서비스를 나누는 단위가 커 중복되는 기능이 많음               |
| 성능          | :star::star::star:       | 굵직하게 분산시킨 아키텍처라 성능은 중간                     |
| 신뢰성        | :star::star::star::star: | 도메인 서비스를 굵직굵직하게 나누기 때문에 다른 분산 아키텍처에 비해 신뢰성이 우수 (분산 트랜잭션이 많지 않고, 네트워크 측면에서 신뢰성이 좋음) |
| 확장성        | :star::star::star:       | 서비스를 나누는 단위가 큼                                    |
| 단순성        | :star::star::star:       | 분산 아키텍처지만 서비스를 나누는 단위가 커 엄청 복잡하지는 않음 |
| 시험성        | :star::star::star::star: | 도메인 범위가 한정되므로 테스트 커버리지가 향상              |

```
오케스트레이션 : 트랜잭션의 워크플로를 제어/관리하는 중재자 서비스를 따로 두고 여러 서비스를 조율하는 기법
코레오그래피 : 서비스가 중재자 없이 서로가 알어서 소통하는 기법
```

