# Chapter 17 - 오케스트레이션 기반 서비스 지향 아키텍처 스타일

## 토폴로지

전통적인 모놀로식 아키텍처는 재사용이 중점이였지만 이는 커플링이 동반되는 문제도 있다는 뜻이다. 재사용을 선호하는 시스템을 설계 하다 보면 결국 상속이나 조합을 이용하기 때문에 커플링이 맺어지게 된다. 

하지만 마이크로서비스는 DDD의 경계 콘택스트 개념을 사용해서 논리적 개념을 물리적으로 모델링하기 때문에 고도의 디커플링 아키텍트를 만들수 있다.

특히 마이크로서비스는 단일 목적만을 가지고 온다. 이는 오케스트레이션 기반의 서비스 지향 아키텍처와 같은 다른 분산 아키텍처보다 서비스 규모가 훨씬 작지만, 각 서비스에는 데이터베이스 및 기타 종속적인 컴포넌트 등 서비스가 독립적으로 작됭되는 데 필요한 모든 것을 갖추고 있다.



## 분산

마이크로서비스는 분산 아키텍처를 형성하지만 디커플링을 유지하고 있기 때문에 애플리케이션을 호스트하는 커다란 멀티테넌트 인프라 아키텍처에서 자주 발생하는 문제들을 간단히 해결할 수 있다. 예를 들면 네트워크 대역폭, 메모리, 디스크 공간 등 여러 가지 혜택을 운영 측면에서 자체 프로세스로 분리하기 때문에 자연스럽게 해소된다. 

하지만 분산 때문에 나타나는 부정적인 요소도 있다. 바로 성능과 트랜잭션 관리이다. 아무래도 네트워크 호출은 메소드 호출보다 느리고, 엔드포인트마다 보안 절차 검증단계를 거쳐야하고, 서비스마다 경계를 넘나드는 트랜잭션을 신경써야 하기 때문에 이러한 부정적인 요소들도 생각해봐야 한다.



## 경계 콘텍스트

마이크로 서비스는 서비스마다 도메인, 워크플로를 모델링하는 경계 콘택스트 개념을 근본으로 한다. 각각의 마이크로 서비스는 어느 한 도메인이나 그 서브도메인을 나타내고, 여러 면에서 마이크로서비스는 도메인 주도 설계의 논리적인 개념을 물리적으로 구현한다.

### 세분도

경계 콘텍스트를 너무 크게 그렇다고 너무 작게 나누면 여러 문제가 발생한다. 예를 들면 단위가 크다 보면 단단히 커플링이 될 수 있고. 그렇다고 지나치게 세분화하면 서비스 간 통신 링크를 다시 구축해야 할 수 있다. 

그렇기 때문에 적절한 몇가지 가이드를 제시하면 다음과 같다.

1. 목적
   * 마이크로서비스가 기능적으로 매우 응집되어 있고 전체 애플리케이션을 대표하여 하나의 핵심 기능을 제공해야 함
2. 트랜잭션
   * 분산 아키텍처에서 트랜잭션으느 문제가 될 소지가 있으므로 아키텍트는 경계해서 설계해야 함
3. 코레오그래피
   * 도메인 격리는 잘되어있지만 서로 광범위한 통신을 해야 하는 경우, 통신 오버헤드를 줄이기 위해 더 큰 서비스로 다시 뭉쳐야 할 수 있는 것을 고려해야 함

이렇게 아키텍트는 여러 가지 옵션을 반복해서 적용해 좋은 설계를 다듬어 가는 것이 좋다.

### 데이터 격리

마이크로서비스는 경계 콘택스트 개념에 따라 데이터를 격리해야 한다. 이때 통합 지점으로 사용되는 공유 스키마, 데이터베이스 등 모든 종류의 커플링을 없애야 한다.

서비스를 단순히 데이터베이스에 있는 엔티티와 비슷하게 모델링해서는 안된다. 즉 아키텍처 전체에 데이터를 분산시킬 수 있을지 결정해야 하고, 도메인을 어떤 팩트에 대한 진실 공급원으로 식별하여 그 값을 가져올 수 있게 잘 조정하든지, 데이터베이스 복제나 캐시 기술로 정보를 분산시키든지 등 구체적인 방안을 마련해야 한다.

이렇게 구성하면 여러팀이 단일 데이터베이스의 속박에서 벗어나게 되어 다양한 도구를 사용 할 수 있게 되고, 고도로 분리된 시스템에서 다른 팀에 영향을 끼치지 않고 적절한 상황에서 적합한 데이터베이스를 선택하여 다른 구현체에 얽매이지 않는 이점이 있다.



## API 레이어

API 레이어는 프록시를 경유하여 간접화하거나 네이밍 서비스 같은 운영 장치에 물려서 유용한 작업을 수행한다. 

API 레이어는 다양한 용도로 활용할 수 있지만 이 아키텍처의 기본 철학에 충실하려면 API 레이어를 중재자나 오케스트레이션 도구로 사용하지 말아야 한다. 모든 비지니스 로직은 경계 컨텍스트 내부에서 일어나야 하며, 오케스트레이션 등의 다른 로직을 중재자에 넣는 것은 안된다.



## 운영 재사용

마이크로서비스가 커플링보다 복제를 선호하지만, 운영 측면의 서비스(모니터링, 로깅 등) 기능을 재사용하는 것이 좋다.

공통 운영 관심사를 각 서비스마다 별도의 컴포넌트에 두고, 해당 팀이나 공유 인프라팀이 소유할 수 있도록 한다. 이를 사이드카 패턴이라 하고 보통 서킷 브레이커, 모니터링 등이 있다.

사이드카 컴포넌트는 팀이 서로 커플링되면 더 유리한 모든 운영 관심사를 도맡아 처리하고, 가령 모니터링 도구를 업그레이드할 때가 되면 공유 인프라팀이 사이드카를 업데이트하는 방식으로 각 마이크로 서비스는 신기능을 받아 사용할 수 있다.



## 프런트엔드

마이크로서비스 아키텍처의 유저 인터페이스는 보통 두가지로 나타난다.

1. 유저 요청을 처리하기 위해 단일 유저 인터페이스가 API 레이어를 통해 호출하는 모놀로식 프런트엔드
   * 보통 리치 데스크톱, 모비일, 웹 애플리케이션 형태로 구현
2. 유저 인터페이스 레벨의 컴포넌트를 백앤드 서비스로 활용하여 유저 인터페이스를 동기적인 수준으로 세분화하고 격리시키는 마이크로 프런트엔드 
   * 각 서비스는 자기 서비스에 해당하는 유저 인터페이스를 내보냄
   * 프런트엔드는 그렇게 내보내진 유저 인터페이스 컴포넌트를 조정
   * 보통 리액트 같은 컴포넌트 기반 웹 프레임워크를 사용 ( 혹은 이 패턴을 지원하는 여러 오픈 소스 프레임워크 )
