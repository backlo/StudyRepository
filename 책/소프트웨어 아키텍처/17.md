# Chapter 17 - 오케스트레이션 기반 서비스 지향 아키텍처 스타일

## 토폴로지

전통적인 모놀로식 아키텍처는 재사용이 중점이였지만 이는 커플링이 동반되는 문제도 있다는 뜻이다. 재사용을 선호하는 시스템을 설계 하다 보면 결국 상속이나 조합을 이용하기 때문에 커플링이 맺어지게 된다. 

하지만 마이크로서비스는 DDD의 경계 콘택스트 개념을 사용해서 논리적 개념을 물리적으로 모델링하기 때문에 고도의 디커플링 아키텍트를 만들수 있다.

특히 마이크로서비스는 단일 목적만을 가지고 온다. 이는 오케스트레이션 기반의 서비스 지향 아키텍처와 같은 다른 분산 아키텍처보다 서비스 규모가 훨씬 작지만, 각 서비스에는 데이터베이스 및 기타 종속적인 컴포넌트 등 서비스가 독립적으로 작됭되는 데 필요한 모든 것을 갖추고 있다.



## 분산

마이크로서비스는 분산 아키텍처를 형성하지만 디커플링을 유지하고 있기 때문에 애플리케이션을 호스트하는 커다란 멀티테넌트 인프라 아키텍처에서 자주 발생하는 문제들을 간단히 해결할 수 있다. 예를 들면 네트워크 대역폭, 메모리, 디스크 공간 등 여러 가지 혜택을 운영 측면에서 자체 프로세스로 분리하기 때문에 자연스럽게 해소된다. 

하지만 분산 때문에 나타나는 부정적인 요소도 있다. 바로 성능과 트랜잭션 관리이다. 아무래도 네트워크 호출은 메소드 호출보다 느리고, 엔드포인트마다 보안 절차 검증단계를 거쳐야하고, 서비스마다 경계를 넘나드는 트랜잭션을 신경써야 하기 때문에 이러한 부정적인 요소들도 생각해봐야 한다.



## 경계 콘텍스트

마이크로 서비스는 서비스마다 도메인, 워크플로를 모델링하는 경계 콘택스트 개념을 근본으로 한다. 각각의 마이크로 서비스는 어느 한 도메인이나 그 서브도메인을 나타내고, 여러 면에서 마이크로서비스는 도메인 주도 설계의 논리적인 개념을 물리적으로 구현한다.

### 세분도

경계 콘텍스트를 너무 크게 그렇다고 너무 작게 나누면 여러 문제가 발생한다. 예를 들면 단위가 크다 보면 단단히 커플링이 될 수 있고. 그렇다고 지나치게 세분화하면 서비스 간 통신 링크를 다시 구축해야 할 수 있다. 

그렇기 때문에 적절한 몇가지 가이드를 제시하면 다음과 같다.

1. 목적
   * 마이크로서비스가 기능적으로 매우 응집되어 있고 전체 애플리케이션을 대표하여 하나의 핵심 기능을 제공해야 함
2. 트랜잭션
   * 분산 아키텍처에서 트랜잭션으느 문제가 될 소지가 있으므로 아키텍트는 경계해서 설계해야 함
3. 코레오그래피
   * 도메인 격리는 잘되어있지만 서로 광범위한 통신을 해야 하는 경우, 통신 오버헤드를 줄이기 위해 더 큰 서비스로 다시 뭉쳐야 할 수 있는 것을 고려해야 함

이렇게 아키텍트는 여러 가지 옵션을 반복해서 적용해 좋은 설계를 다듬어 가는 것이 좋다.

### 데이터 격리

마이크로서비스는 경계 콘택스트 개념에 따라 데이터를 격리해야 한다. 이때 통합 지점으로 사용되는 공유 스키마, 데이터베이스 등 모든 종류의 커플링을 없애야 한다.

서비스를 단순히 데이터베이스에 있는 엔티티와 비슷하게 모델링해서는 안된다. 즉 아키텍처 전체에 데이터를 분산시킬 수 있을지 결정해야 하고, 도메인을 어떤 팩트에 대한 진실 공급원으로 식별하여 그 값을 가져올 수 있게 잘 조정하든지, 데이터베이스 복제나 캐시 기술로 정보를 분산시키든지 등 구체적인 방안을 마련해야 한다.

이렇게 구성하면 여러팀이 단일 데이터베이스의 속박에서 벗어나게 되어 다양한 도구를 사용 할 수 있게 되고, 고도로 분리된 시스템에서 다른 팀에 영향을 끼치지 않고 적절한 상황에서 적합한 데이터베이스를 선택하여 다른 구현체에 얽매이지 않는 이점이 있다.



## API 레이어

API 레이어는 프록시를 경유하여 간접화하거나 네이밍 서비스 같은 운영 장치에 물려서 유용한 작업을 수행한다. 

API 레이어는 다양한 용도로 활용할 수 있지만 이 아키텍처의 기본 철학에 충실하려면 API 레이어를 중재자나 오케스트레이션 도구로 사용하지 말아야 한다. 모든 비지니스 로직은 경계 컨텍스트 내부에서 일어나야 하며, 오케스트레이션 등의 다른 로직을 중재자에 넣는 것은 안된다.



## 운영 재사용

마이크로서비스가 커플링보다 복제를 선호하지만, 운영 측면의 서비스(모니터링, 로깅 등) 기능을 재사용하는 것이 좋다.

공통 운영 관심사를 각 서비스마다 별도의 컴포넌트에 두고, 해당 팀이나 공유 인프라팀이 소유할 수 있도록 한다. 이를 사이드카 패턴이라 하고 보통 서킷 브레이커, 모니터링 등이 있다.

사이드카 컴포넌트는 팀이 서로 커플링되면 더 유리한 모든 운영 관심사를 도맡아 처리하고, 가령 모니터링 도구를 업그레이드할 때가 되면 공유 인프라팀이 사이드카를 업데이트하는 방식으로 각 마이크로 서비스는 신기능을 받아 사용할 수 있다.



## 프런트엔드

마이크로서비스 아키텍처의 유저 인터페이스는 보통 두가지로 나타난다.

1. 유저 요청을 처리하기 위해 단일 유저 인터페이스가 API 레이어를 통해 호출하는 모놀로식 프런트엔드
   * 보통 리치 데스크톱, 모비일, 웹 애플리케이션 형태로 구현
2. 유저 인터페이스 레벨의 컴포넌트를 백앤드 서비스로 활용하여 유저 인터페이스를 동기적인 수준으로 세분화하고 격리시키는 마이크로 프런트엔드 
   * 각 서비스는 자기 서비스에 해당하는 유저 인터페이스를 내보냄
   * 프런트엔드는 그렇게 내보내진 유저 인터페이스 컴포넌트를 조정
   * 보통 리액트 같은 컴포넌트 기반 웹 프레임워크를 사용 ( 혹은 이 패턴을 지원하는 여러 오픈 소스 프레임워크 )



## 통신

마이크로서비스는 동기로 할지, 비동기로 할지 근본적인 통신 방식을 결정해야 한다. 올바른 통신 스타일을 발견하면 서비스를 디커플링하면서 유용한 방향으로 나아가기 때문이다.

일반적으로 마이크로 서비스 아키텍처는 ``프로토콜 인지 이종 간 상호 운용성``을 활용한다.

#### 포로토콜 인지

마이크로서비스는 운영 커플링을 방지하고자 중앙 통합 허브를 갖고 있지 않기 때문에 서비스는 다른 서비스를 호출할 때 어떤 프로토콜을 사용할지 알아야 한다.

보통 여러 서비스가 상대방을 호출하는 방식인 REST 레벨이나 메시지 큐 등을 표준화 한다.

#### 이종

마이크로서비스는 분산 아키텍처라서 각 서비스마다 구현 기술 스택이 상이할 수 있다. 즉 서비스마다 사용하는 플랫폼이 저마다 다른 폴리글랏 환경을 완벽하게 지원해야 한다. ( 이종 )

#### 상호 운용성

여러 서비스가 호출한다는 뜻으로 마이크로서비스에서 트랜잭셔널 메서드 호출을 권장하지는 않지만, 때에 따라 네트워크를 통해 다른 서비스를 호출하면서 협력해야 한다.



### 코레오그래피와 오케스트레이션

* 코레오그래피
  * 코레오그래피는 브로커 이벤트 기반의 아키텍처와 통신 스타일이 동일하다. 
  * 즉 중앙의 중재자가 따로 없고 경계 콘텍스트를 둔다. 
  * 그리고 코레오그래피에서 각 서비스는 중앙 중재자 없이 자신의 필요에 따라 다른 서비스를 호출할 수 있다.
  * 하지만 코레오그래피 아키텍트는 최대한 디커플링한다는 철학 때문에 에러 처리, 조정 같은 공통적인 문제를 해결하기 복잡할 수 있다. 
  * 대표적인 예가 컨트롤러 패턴으로 어떤 한 서비스가 명목상 중재자 역할을 하는 셈인데, 서비스가 점점 복잡해지는 단점이 있다.

* 오케스트레이션
  * 오케스트레이션을 사용하면 코레오그래피의 단점을 극복할 수 있다. 
  * 오케스트레이션은 전역 중재자를 따로 두지 않고 여러 서비스를 조정해야 할 경우 스스로 로컬 중재자를 만들어 컨트롤하는 방법이다.
  * 이는 복잡한 처리를 담당하면서 조정 역할도 수행하는 중재자를 두면 서비스간 커플링은 발생하지만 어느 한 서비스가 조정 작업을 전담하므로 다른 서비스는 영향을 받지 않는다. 

보통 커플링이 적을 수록 통신 속도가 증가하고 병목이 줄기 때문에 오케스트레이션보다는 코레오그래피를 더 많이 사용하는 편이다.



### 트랜잭션과 사가

마이크로 서비스는 특성상 서비스 경계를 넘나드는 트랜잭션은 그 자체로 마이크로서비스 아키텍처의 핵심 디커플링 원칙에 위배된다. 만약 여러 서비스에 걸쳐 트랜잭션을 걸고 싶은 경우 지나치게 세분화 한 것이기 때문에 컴포넌트 세분도를 다시 잡아야하는 것이 좋다.

물론 항상 예외는 있기 때문에 어쩔 수 없이 두 서비스가 서로 완전히 다른 아키텍처 특성을 필요로 하는 경우라면, 트랜잭션 오케스트레이션 처리 패턴인 사가 패턴을 사용하면 된다.

* 사가 패턴
  * 중재자는 트랜잭션을 구성하는 파트를 하나씩 호출하여 성공/실패 여부를 기록하고 그 결과에 따라 흐름을 조정한다.
  * 예를 들면 중재자는 성공한 경우 그대로 두고 (보류), 실패한 경우 성공했던 모든 트랜잭션 파트에게 과거에 처리했던 내용에 ``언두(undo)`` 요청을 보내는 방식이다.
  * 이런 종류의 트랜잭션 조정을 보상 트랜잭션 프레임워크라고 한다.
  * 만약 여기서 비동기 요청이 끼어들고, 보류된 트랜잭션 상태에 따라 새로운 요청이 등장하면 설계가 무척 복잡해진다.
  * 또한 네트워크 레벨에서도 조정 트래픽이 꽤 많이 발생한다.
  * 트랜잭션 작업마다 두 / 언두 로직을 개발하는 식으로 보상 트랜잭션 프레임워크를 구현해 조정은 덜 필요하게 만들 수 있지만 설계, 구현 디버깅 작엽량이 2배가 된다.
  * 또한 서비스에 트랜잭션으르 걸어주는 방법도 있지만, 모놀리스와 다를게 없기 때문에 마이크로서비스를 사용할 필요가 없어진다.
  * 그렇기 때문에 적당히 필요한 경우에 사가 패턴을 사용할 것을 권고한다.



## 아키텍처 등급

| 아키텍처 특성 | 별점                           | 설명                                                         |
| ------------- | ------------------------------ | ------------------------------------------------------------ |
| 분할 유형     | 도메인                         | 각 서비스의 경계 도메인이 일치해야 함                        |
| 퀀텀 수       | 하나 또는 여러개               | 가장 독보적인 퀀텀을 갖고 있음                               |
| 배포성        | :star::star::star::star:       |                                                              |
| 탄력성        | :star::star::star::star::star: | 자동화 및 운영과의 지능적인 통합에 많이 의존하므로 탄력성을 줄일 수 있음 |
| 진화성        | :star::star::star::star::star: | 고도의 디커플링으로 인해 점진적으로 변화하는 비즈니스에 안성맞춤 |
| 내고장성      | :star::star::star::star:       | 정상적인 상황에서 독립적인 단일 목적의 서비스는 내고장성이 높음 (과용하면 문제) |
| 모듈성        | :star::star::star::star::star: |                                                              |
| 전체 비용     | :star:                         |                                                              |
| 성능          | :star::star:                   | 특성상 잦은 네트워크 호출로 인해 성능 오버헤드가 높음 (데이터 캐시나 복제로 어느정도 해결) |
| 신뢰성        | :star::star::star::star:       | 정상적인 상황에서 독립적인 단일 목적의 서비스는 신뢰성이 높음 (과용하면 문제) |
| 확장성        | :star::star::star::star::star: | 서비스 디스커버리를 통한 확장을 해결                         |
| 단순성        | :star:                         |                                                              |
| 시험성        | :star::star::star::star:       |                                                              |
