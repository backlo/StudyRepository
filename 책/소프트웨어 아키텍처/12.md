# Chapter 12 - 마이크로커널 아키텍처 스타일

## 토폴로지

마이크로커널 아키텍처 스타일은 **코어 시스템**과 **플러그인 컴포넌트**라는 두 가지 아키텍처 요소로 구성된 비교적 단순한 모놀리식 아키텍처이다.

이 아키텍처 스타일은 단일 모놀로식 배포 단위로 패키징해 다운로드, 설치 등 써드파티 제품에 설치되는 제품 기반 애플리케이션에 적합하며, 비제품 고객 비즈니스 애플리케이션에도 많이 사용된다.

### 코어 시스템

코어 시스템은 시스템을 실행시키는 데 필요한 최소한의 기능 혹은 커스텀 처리 없이 애플리케이션을 관통하는 정상 경로라 정의할 수 있다.

가장 대표적인 예가 이클립스이다. 
이클립스 코어는 기본적인 텍스트 에디터에 불과한데, 플러그인을 추가해야 비로소 쓸 만한 제품이 된다. 

코어 시스템의 순환 복잡도를 없애고 별도의 플러그인 컴포넌트를 장착하면 확장성, 유지보수성을 물론 시험성도 좋아진다.

다음 예를 보자

* 전자 제품 별로 중고 가격을 적용시키는 코드

  ```java
  public void assessDevice(String deviceID) {
  	if (deviceID.equals("iPhone6s")) {
      assessiPhone6s();
    }	 else if (deviceID.equals("iPad1")) {
      assessiPad1();
    } else if (...) {
      ...
    } else {
      ...
    }
    ...
  }
  ```

위 코드는 클라이언트 정보에 따라 if-else로 감정되고 있다. 즉 코어 시스템이 클라이언트에 종속된 코드를 가지고 있음으로써 순환 복잡도가 높아진다.

이를 해결하기 위해 다음과 같이 플러그인 컴포넌트를 따로 만들면 훨씬 효율적인 코드를 만들 수 있다.

* 플러그인을 찾아 호출하는 방식의 코드

  ```java
  public void assessDevice(String deviceID) {
  	String plugin = pluginRegistry.get(deviceID);
    Class<?> theClass = Class.forName(plugin);
    Constructor<?> constructor = theClass.getConstructor();
    DevicePlugin devicePlugin = (DevicePlugin)constructor.newInstance();
    DevicePlugin.assess();
  }
  ```

이렇게 개별 클라이언트 플러그인 컴포넌트를 만들어 끼우면 나머지 처리 흐름과 무관한 로직을 따로 떼어낼 수 있고 차후 확장도 가능하다.

코어 시스템 규모에 따라 레이어드 아키텍처나 혹은 모듈러 모놀리스 아키텍처로 구현할 수 있다. 경우에 따라 코어 시스템을 별도 배포하는 특정한 플러그인 컴포넌트를 둘 수도 있다.

코어 시스템이 레이어드 아키텍처일 경우 프레젠테이션 레이어는 코어 시스템에 내장하거나 별도의 UI를 구현하고 코어 시스템은 백엔드 서비스를 제공할 수도 있다.

### 플러그인 컴포넌트

플러그인 컴포넌트는 특수한 처리 로직, 부가 기능, 그리고 코어 시스템을 개선 / 확장하기 위한 커스텀 코드가 구현된 컴포넌트를 말한다. 이는 변동성이 매우 큰 코드를 분리하여 애플리케이션 내부의 유지보수성, 시험성을 높이는 것이다.

플러그인 컴포넌트와 코어 시스템은 일반적으로 점대점 통신을 한다. 즉 코어 시스템에 플러그인을 연결하는 **파이프**는 대부분 플러그인 컴포넌트의 진입점 클래스를 호출하는 메소드나 함수 코드를 말한다.

다음은 플러그인 컴포넌트의 특징과 팁 그리고 주의사항이다.

1. 점대점 컴포넌트는 공유 라이브러리(JAR, DLI, GEM), 패키지명(Java), 네임스페이스(C#)등으로 구현할 수 있다.
2. 플러그인 컴포넌트를 코드베이스나 IDE 프로젝트 내부으 개별 네임스페이스 또는 패키지명으로 구현하면 더 알기 쉽다. ( app.plugin.<도메인>.<콘텍스트> )
3. 플러그인 컴포넌트가 반드시 코어 시스템과 점대점 통신을 해야 하는 것은 아닌 원격 액세스 구조도 가능하다.
   1. 즉 각 플러그인을 스탠드얼론 서비스로 만들어 REST나 메시징 등 다양한 방법으로 호출 할 수 있다.
   2. 이는 플러그인 컴포넌트를 개별 서비스로 구현해 원격 액세스하는 방법은 커플링이 낮아져 확장성과 처리량이 개선되고, 특수한 프레임워크 없이도 런타임 변경이 가능한 장점을 가지고 있다.
   3. 하지만 원격 플러그인에 접속하려면 마이크로커널 아키텍처를 모놀리식 아닌 분산 아키텍처로 바꿔야하기 때문에 서드파티 온프렘 제품은 구현/배포가 쉽지 않다.
   4. 그리고 전반적으로 복잡도와 비용이 높아져 전체 배포 토폴로지가 상당히 난해해진다.
4. 플러그인 컴포넌트가 중앙 공유 데이터베이스에 직접 접속할 일은 거의 없고 주로 코어 시스템이 그 역할을 담당할 것이다. ( 디커플링 때문에 -> 코어 시스템에만 영향을 미치고 플러그인 컴포넌트는 영향을 미치지 않는다. )



## 레지스트리

코어 시스템은 어떤 플러그인을 사용할 수 있는지,  그 플러그인을 가지고 오려면 어떻게 해야하는지 알고 있어야 한다.

가장 일반적인 구현 방법은 플러그인 레지스트리를 경유하는 것이다. 이 레지스트리에는 플러그인 명칭, 데이터 계약, 세부 원격 액세스 프로토콜 등 각 플러그인 모듈에 관한 정보가 있을 것이다.

또한 레지스트리는 코어 시스템이 소유한 내부 맵 구조처럼 단순 할 수도 있고, 외부 배포된 시스템에 내장된 복잡한 형태일 수도 있다.



## 계약

플러그인 컴포넌트와 코어 시스템 간의 계약은 보통 플러그인 컴포넌트의 도메인 단위로 표준화되어 있다. 그리고 플러그인 컴포넌트가 수행하는 기능 및 입출력 데이터는 계약에 명시되어 있다.

그렇기 때문에 일반적으로 코어 시스템이 각 플러그인 별 코드를 필요로 하지 않도록 플러그인 계약과 우리가 정한 표준 계약 간의 어댑터를 만든다.



## 아키텍처 특성 등급

| 아키텍처 특성 | 별점                           | 설명                                                         |
| ------------- | ------------------------------ | ------------------------------------------------------------ |
| 분할 유형     | 도메인 및 기술                 |                                                              |
| 퀀텀 수       | 1                              | 모든 요청은 코어 시스템을 통해 유입되어 독립적인 플러그인 컴포넌트로 흘러가기 때문에 |
| 배포성        | :star::star::star:             | 독립적인 플러그인 컴포넌트로 분리할 수 있어서                |
| 탄력성        | :star:                         | 모놀로식 배포 탓                                             |
| 진화성        | :star::star::star:             | 개선 / 확장에 비교적 용이                                    |
| 내고장성      | :star:                         | 모놀로식 배포 탓                                             |
| 모듈성        | :star::star::star:             | 독립적인 자기 완비형 플러그인 컴포넌트를 통해 기능을 추가, 삭제, 변경할 수 있어서 (개선/ 확장이 용이함) |
| 전체 비용     | :star::star::star::star::star: | 레이어드 아키텍처와 비슷함                                   |
| 성능          | :star::star::star:             | 플러그인 아키텍처는 대부분 규모가 작고 레이어드 아키텍처처럼 갈수록 커지지 않음 |
| 신뢰성        | :star::star::star:             | 독립적인 플러그인 컴포넌트로 분리할 수 있어서                |
| 확장성        | :star:                         | 모놀로식 배포 탓                                             |
| 단순성        | :star::star::star::star:       | 레이어드 아키텍처와 비슷함                                   |
| 시험성        | :star::star::star:             | 독립적인 플러그인 컴포넌트로 분리할 수 있어서                |







