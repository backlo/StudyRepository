# Chapter 3 -  모듈성

모듈성을 정의하기엔 쉽지 않지만 간단히 정리하자면 모듈성은 일종의 구성 원리이다.

아키텍트는 끊임없이 에너지를 소비해서 시스템을 구조적으로 탄탄하게 유지해야한다. 그렇기 때문에 모듈이 확실히 구분되고 모듈 간 통신이 잘 되어야 한다.



## 정의

사전에 모듈을 찾아보면, `복잡한 구조를 만드는 데 쓰이는 각각의 표준화한 부품이나 독립적인 단위`라고 나온다. 즉 우리는 모듈성을 이용해 객체 지향 언어의 클래스나 함수형 언어의 함수가 될 만한 서로 연관된 코드를 논리적으로 묶어 코드베이스화 한다.

자바 같은 경우 패키지를 사용해 모듈화를 시킨다. 여기서 아키텍트는 개발자가 코드를 어떻게 패키징하는지 반드시 알아야 한다. 그 이유는 여러 패키지가 서로 단단히 커플링되어 있으면 그 중 하나를 다른 작업에 재사용하기 어렵기 때문이다.



## 모듈성 측정

### 응집

응집은 한 모듈의 파트가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타낸다. 다시 말해, 모듈을 구성하는 파트가 서로 얼마나 연관되어 있는가, 하는 것이다.

과학자들이 응집도의 측정 범위를 정의했는데, 가장 좋은것 부터 나쁜것 순으로 나열해보겠다.

1. 기능적 응집
   * 모듈의 각 파트는 다른 파트와 연관되어 있고 기능상 꼭 필요한 모든 것이 모듈에 들어있다.
2. 순차적 응집
   * 두 모듈이, 한쪽이 데이터를 출력하면 다른 한쪽이 그것을 입력 받는 형태로 상호작용한다.
3. 소통적 응집
   * 두 모듈이, 각자 정보에 따라 작동하고 어떤 출력을 내는 형태로 통신 체인을 형성한다.
4. 절차적 응집
   * 두 모듈은 정해진 순서대로 실행해야 한다.
5. 일시적 응집
   * 모듈은 시점 의존성에 따라 연관된다. (예를 들면 관련없는 것들을 초기화)
6. 논리적 응집
   * 모듈의 내부 데이터는 기능적이 아니라, 논리적으로 연관되어 있다. (예를 들면 StringUtils 클래스에서 정적 메소드가 많은데 서로 연관성이 없는 경우)
7. 동시적 응집
   * 같은 소스 파일에 모듈 구성 요소가 들어 있지만 그 외에는 아무 연관성도 없다.

따라서 이러한 응집들을 쉽게 파악하고 더 좋은 트레이드 오프를 분석할 수 있게 과학자들은 메소드의 응집 결여도(LCOM)을 개발했다.

LCOM은 공유 필드를 통해 공유되지 않는 메소드의 총 개수를 말한다. 

예를 들면 프라이빗 필드 a,b가 있는 클래스에서 a만 액세스하는 메소드가 있고 b 만 액세스하는 메소드가 있다고 가정하자. 그럼 공유 필드 (a, b)를 통해 공유되는 메소드보다 공유되지 않는 메소드가 더 많기 때문에 이 클래스의 LCOM 점수가 높다고 말할 수 있다. 즉 메소드의 응집 결여도가 높다.

LCOM 메트릭은 아키텍처 스타일을 전환하기 위해 코드베이스를 분석하는 아키텍트에게 매우 유용하다.



### 커플링

커플링은 구심 커플링과 원심 커플링이 있는데 구심 커플링은 컴포넌트, 클래스 함수 등의 코드 아티팩트로 유입되는 접속 수를, 원심 커플링은 다른 코드 아티팩트로 유출되는 접속 수를 나타낸다.



### 추상도, 불안정도, 메인 시퀀스로부터의 거리

추상도는 추상 아티팩트와 구상 아티팩트의 비율, 즉 인터페이스와 구현체의 추상화 정도를 나타낸다. (구현 대비 추상화 정도)

즉 메인에 다 때려넣은 코드베이스도 있고, 너무 잘게 추상화시켜 무슨 일을 하는 빈인지 알아낼려면 하나절 걸리는 코드베이스도 있다.

추상도의 식은 다음과 같다.

* 모듈에 있는 추상 요소 / 모둘에 있는 구상 요소
* 예를 들면 5000줄을 메인메소드에 구현했을때 추상도는 1/5000으로 0에 수렴한다.

불안정도의 식은 다음과 같다.

* 원심 커플링 / (원심 커플링 + 구심 커필링)
* 불안정도는 코드베이스의 변동성을 의미한다.
* 즉 불안정도가 높은 코드베이스는 변경시 커플링이 높아 더 깨지기 쉽다.
* 예를 들면 여러 다른 클래스를 호출해서 작업을 위임하는 클래스는 호출되는 메소드 중 하나라도 변경되면 호출하는 이 클래스 역시 잘못될 공산이 매우 높다.



### 메인 시퀀스로부터의 거리

메인 시퀀스로부터의 거리는 아키텍처 구조를 평가하는 몇가지 전체적인 메트릭중 하나이다.

메인 시퀀스로부터의 거리의 식은 다음과 같다.

* 메인시퀀스로부터의 거리 식 : 추상도 + 불안정도 - 1
* 항상 0과 1사이의 값
* 메인 시퀸스 선이 이상적인 선인데 이 선에 가까울 수록 클래스 균형이 잘 이루어져있다.
* 너무 오른쪽 위로 치우쳐지면 추상화를 많이 한것이고, 너무 왼쪽 아래로 치우쳐지면 추상화를 거의 안했다고 볼 수 있다.



### 커네이선스

커네이선스는 변화 종속성으로써, 어느 한쪽을 바꾸면 다른 쪽도 함께 바꾸어야 전체적으로 정합성이 유지되는 상태를 말한다.

커네이선스는 크게 동적과 정적으로 나뉘는데 아래 한번 살펴보겠다.

* 정적 커네이선스 - 소스 코드 레벨의 커플링으로, 아키텍트는 구심적이든, 원심적이든 다음 종류의 정적 커네이선스를 뭔가에 커플링된 정도라 보는 것이다.
  * 명칭 커네이선스
    * 여러 컴포넌트의 엔티티명이 일치해야 한다.
  * 타입 커네이선스
    * 여러 컴포넌트의 엔티티 타입이 일치해야 한다.
  * 의미 커네이선스 또는 관례 커네이선스
    * 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다.
  * 위치 커네이선스
    * 여러 컴포넌트는 값의 순서가 일치해야 한다. (예를 들면 매개변수 순서)
  * 알고리즘 커네이선스
    * 여러 컴포넌트는 특정 알고리즘이 일치해야 한다. (동일한 인풋, 동일한 아웃풋)
* 동적 커네이선스 - 런타임 호출을 분석하는 또 다른 유형의 커네이선스이다.
  * 실행 커네이선스
    * 여러 컴포넌트의 실행 순서가 중요하다.
  * 시점 커네이선스
    * 여러 컴포넌트의 실행 시점이 중요하다.
  * 값 커네이선스
    * 상호 연관된 다수의 값들을 함께 변경할 때 발생한다. ( 다 변경되거나, 다 변경 안되거나 )
  * 식별 커네이선스
    * 여러 컴포넌트가 동일한 엔티티를 참조할 때 발생한다. (독립적인 컴포넌트가 자료구조를 공유해서 업데이트 하는 경우)
* 커네이선스 속성 
  * 강도
    * 아키텍트는 개발자가 어떤 유형의 커네이선스를 얼마나 쉽게 리팩토링할 수 있는지에 따라 커네이선스 강도를 결정한다.
    * 정적 커네이선스는 개발자가 간단히 소스 코드를 분석하거나 최신 도구를 활용하면 어렵지 않게 개선할 수 있다.
  * 지역성
    * 커네이선스의 지역성은 코드베이스의 모듈들이 서로 얼마나 가까이 있는가 이다.
    * 동일한 모듈에서 근접한 코드는 보통 더 분리된 코드보다 높은 형태의 커네이선스를 가진다.
    * 즉 모듈을 서로 떨어뜨렸을 때 커플링이 형편없는 형태의 커네이선스는 모듈을 서로 가까이 붙여 놓는 식으로 개선할 수 있다.
  * 정도
    * 커네이선스 정도는 커네이선스가 미치는 영향의 규모에 관한 것이다. (영향이 소수의 클래스에 미치는가, 다수의 클래스에 미치는가)
    * 이 값이 작을수록 코드베이스 입장에서는 바람직하다.
    * 이 값을 작게 하기 위해서는 다음과 같이 하면 좋다.
      1. 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화한다.
      2. 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화한다.
      3. 캡슐화 경계 내부에서 커네이선스를 최대화 한다.

전설적인 소프트웨어 아키텍처 혁신가, 짐 웨이리치는 커네이선스 개념을 이렇게 나타냈다.

> 정도의 규칙
>
> * 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라
>
> 지역성의 규칙
>
> * 소프트웨어 엘리먼트 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 사용하라.



### 커플링과 커네이선스 메트릭을 통합

아키텍트 관점에서 커플링과 커네이선스 목표가 상이하지만 중첩된다.

구조적 프로그래밍은 들어오고 나가는 것에만 관심있는 반면, 커네이선스는 여러 가지 요소가 서로 어떻게 커플링되는지에 주목한다.



## 모듈에서 컴포넌트로

연관된 코드의 묶음을 모듈이라는 일반 용어로 표현하지만, 대부분의 플랫폼은 소프트웨어 아키텍트에게 핵심 구성 요소 중 하나인 컴포넌트 형태로 지원한다.

