# Chapter 8 - 컴포넌트 기반 사고

아키텍트는 보통 모듈을 물리적으로 패키징한 컴포넌트의 구현이다.



## 컴포넌트의 범위

컴포넌트는 아티팩트를 한데 묶어 필요시 중첩시켜 계층화하는, 즉 언어에 특정한 메커니즘을 제공한다.

예를 들면 **연관된 코드를 묶어 래퍼를 시키는 라이브러리**를 말할 수 있다. 라이브러리는 호출부 코드와 동일한 메모리 주소에서 실행되며 해당 언어의 함수 호출 메커니븜을 이용해 통신한다. 또는 아키텍처에서 서브시스템이나 레이어 형태로도 나타내며, 이벤트 프로세서, 분산 서비스 등을 말할 수있다.

아키텍트가 반드시 컴포넌트를 사용해야 하는 것은 아니다. 더 높은 수준에서 모듈성을 가지는 것이 더 유용할 때가 많기 때문에 최상위 분할부터 시작해보는것도 중요한 항목 중에 하나다.



## 아키텍트 역할

 아키텍트는 아키텍처 내부의 컴포넌트를 저으이, 개선, 관리, 통제하는 일을 한다. 그렇기 때문에 새 프로젝트를 시작한 아키텍트는 무엇보다 먼저 컴포넌틀르 식별해야 하나, 그 전에 아키텍처를 분할하는 방법을 반드시 이해해야 한다.

### 아키텍처 분할

* 최상위 분할 - 기술적 분할 vs 도메인 분할
  * 기술적 분할
    * 보통 레이어드 아키텍처
    * 이렇게 구성하면 개발자가 코드를 찾기 쉬움
    * 또한 콘웨이 법칙처럼 비슷한 사람들끼리 모여 소통할수 있음
    * 즉 시스템 컴포넌트를 프레젠테이션, 비즈니스 규칙, 퍼시스턴스 등의 기술적 능력에 따라 구성된다.
    * 장점
      * 커스텀 코드가 명확하게 분리된다.
      * 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있다.
    * 단점
      * 전역 커플링이 더 높다. 따라서 공통 또는 로컬 컴포넌트 중 하나라도 변경되면 다른 모든 컴포넌트가 영향을 받을 가능성이 높다.
      * 개발자가 공통 레이어, 로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수 있다.
      * 일반적으로 데이터 레벨의 커플링이 높다. 이런 시스템은 대개 애플리케이션 아키텍트, 데이터 아키텍트가 서로 협력하여 단일 데이터베이스를 구성하고 여기에 각종 도메인을 포함시키기 때문에 나중에 아키텍트가 분산 시스템으로 아키텍처를 옮기려고 할 경우 데이터 관계를 파헤치는 작업이 어렵다.
  * 도메인 분할
    * 보통 모듈러 모놀리스 아키텍처
    * 서로 독립적으로 분리된 도메인 또는 워크플로를 식별하는데, 이는 MSA의 근본이기도 함
    * 각 컴포넌트는 서로 중첩될 때가 많기 때문에 퍼시스턴스 라이블러리를 사용하거나 별도의 레이어에 비즈니스 규칙을 둠
    * 장점
      * 세부 구현보다 비즈니스 기능에 더 가깝게 모델링 된다.
      * 역 콘웨이 전략을 활용하여 도메인별 다목적팀을 구성하기 쉽다
      * 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝게 맞출 수 있다.
      * 메시지 흐름이 문제 영역과 일치한다.
      * 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다.
    * 단점
      * 유저 정의 코드가 여기저기 널려 있다.



## 컴포넌트 식별 흐름

컴포넌트 식별은 다음과 같은 형태로 흐름을 갖게 된다.

> 초기 컴포넌트 식별 -> 요구사항을 컴포넌트에 할당 	->	 역할 및 책임 분석 -> 아키텍처 특성 분석 -> 컴포넌트 재구성 -> 역할 및 책임 분석 ...

### 초기 컴포넌트 식별

* 아키텍트는 소프트웨어 프로젝트의 소스 코드가 생기기 전에 적용할 최상위 분할의 유형에 따라 최상위 컴포넌트를 어디서부터 시작할지 결정해야 한다. 
* 또한 그 밖에도 아키텍트는 원하는 컴포넌트를 자유롭게 구성하면서 어느 기능을 어디에 둘지 도메인 기능을 매핑한다.

### 요구사항을 컴포넌트에 할당

* 초기 컴포넌트를 식별한 후, 이카텍트는 컴포넌트에 요구사항을 대입해서 잘 맞는지 확인한다.
* 이 과정에서 컴포넌트를 새로 만들거나 기존 컴포넌트를 통합하고, 하는 일이 너무 많은 컴포넌트는 분해할 수 있다.

### 역할 및 책임 분석

* 컴포넌트에 스토리를 대입할 때. 아키텍트는 요구사항을 파악하는 단계에서 밝혀진 역할과 책임도 살펴보고 세분도(얼마나 잘 나뉘어져 있는지)가 적합한지 확인한다.

### 아키텍처 특성 분석

* 컴포넌트에 요구사항을 대입할 때 아키텍트는 앞서 식별한 아키텍쳐 특성들이 컴포넌트 분할 및 세분도에 어떤 영향을 미치는지 살펴봐야 한다.
* 기능적인 관점이 아닌 아키텍처 특성을 분석하면 더 하위 컴포넌트로 잘게 나뉠수 있다.

### 컴포넌트 재구성

* 아키텍트는 개발자들과 함께 지속적으로 컴포넌트 설계를 반복한다.



## 컴포넌트 세분도

컴포넌트를 너무 잘게 나누면 통신이 너무 많아지고, 그렇다고 크게 나누면 내부적으로 커플링이 증가해 배포, 테스트가 어려워지고 모듈성 관점에서도 부정적인 영향을 미치기 때문에 적당히 세분도를 나눠야 한다.



## 컴포넌트 설계

### 컴포넌트 발견

* 엔티티 함정
  * 엔티티 함정은 아키텍트가 데이터베이스 관계를 애플리케이션의 워크플로로 오해할 때 벌어진다.
  * 엔티티 함정에 빠져 생성된 컴포넌트는 너무 큼지막하게 나뉘어지기 때문에 소스코드의 전체적인 구조와 패키징 관점에서 개발팀에게 지침에 될 만한 것은 하나도 없다.
* 액태/액션 접근법
  * 애플리케이션에서 뭔가 일을 하는 액터와 그들이 수행하는 액션을 식별하고 시스템의 대표적인 유저와 이들이 시스템에서 어떤 종류의 일을 하는지 찾아내는 기법이다.
* 이벤트 스토밍
  * 요구사항과 식별된 역할에 따라 시스템에서 어떤 이벤트가 일어나는지 파악하고 컴포넌트를 이벤트와 메시지 핸들러 중심으로 구축하는 기법이다.
* 워크플로 접근법
  * 이벤트 스토밍과 비슷하지만 메시지 기반 시스템을 구축하는데 있어서 제약조건은 없다.
  * 핵심 역할을 식별하고 이 역할이 관여하는 워크플로 유형을 결정하며 그렇게 식별된 활동에 따라 컴포넌트를 구축하는 기법이다.



